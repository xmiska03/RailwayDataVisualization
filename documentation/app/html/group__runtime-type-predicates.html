<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visualization of data from MMS: Runtime-type-predicates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Visualization of data from MMS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Runtime-type-predicates</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2aef37f781085bfbfe78b44c6110d089" id="r_ga2aef37f781085bfbfe78b44c6110d089"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga2aef37f781085bfbfe78b44c6110d089">arrow::is_integer</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga2aef37f781085bfbfe78b44c6110d089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an integer type (signed or unsigned)  <br /></td></tr>
<tr class="separator:ga2aef37f781085bfbfe78b44c6110d089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4124c6de5880daeacfed37da75c576e4" id="r_ga4124c6de5880daeacfed37da75c576e4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga4124c6de5880daeacfed37da75c576e4">arrow::is_signed_integer</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga4124c6de5880daeacfed37da75c576e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a signed integer type.  <br /></td></tr>
<tr class="separator:ga4124c6de5880daeacfed37da75c576e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eefa3fccb703148e2a8b70c632e89fa" id="r_ga0eefa3fccb703148e2a8b70c632e89fa"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga0eefa3fccb703148e2a8b70c632e89fa">arrow::is_unsigned_integer</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga0eefa3fccb703148e2a8b70c632e89fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an unsigned integer type.  <br /></td></tr>
<tr class="separator:ga0eefa3fccb703148e2a8b70c632e89fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54aa5d70bb3008ffd838f2c37a9586a5" id="r_ga54aa5d70bb3008ffd838f2c37a9586a5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga54aa5d70bb3008ffd838f2c37a9586a5">arrow::is_floating</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga54aa5d70bb3008ffd838f2c37a9586a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a floating point type.  <br /></td></tr>
<tr class="separator:ga54aa5d70bb3008ffd838f2c37a9586a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga049e542444b7d2f87dd06331485a5bea" id="r_ga049e542444b7d2f87dd06331485a5bea"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga049e542444b7d2f87dd06331485a5bea">arrow::is_numeric</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga049e542444b7d2f87dd06331485a5bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a numeric type.  <br /></td></tr>
<tr class="separator:ga049e542444b7d2f87dd06331485a5bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7ace06bd99e8890324051b28316e53" id="r_ga9b7ace06bd99e8890324051b28316e53"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga9b7ace06bd99e8890324051b28316e53">arrow::is_decimal</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga9b7ace06bd99e8890324051b28316e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a decimal type.  <br /></td></tr>
<tr class="separator:ga9b7ace06bd99e8890324051b28316e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4905eeda5e969c2f166c4e420cd1f87" id="r_gaf4905eeda5e969c2f166c4e420cd1f87"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gaf4905eeda5e969c2f166c4e420cd1f87">arrow::is_run_end_type</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gaf4905eeda5e969c2f166c4e420cd1f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a type that can be used as a run-end in Run-End Encoded arrays.  <br /></td></tr>
<tr class="separator:gaf4905eeda5e969c2f166c4e420cd1f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf640ac17b8c546ca403580f01a65b82c" id="r_gaf640ac17b8c546ca403580f01a65b82c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gaf640ac17b8c546ca403580f01a65b82c">arrow::is_primitive</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gaf640ac17b8c546ca403580f01a65b82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a primitive type.  <br /></td></tr>
<tr class="separator:gaf640ac17b8c546ca403580f01a65b82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf48e4c710f9a8c627971fd5947acf44" id="r_gadf48e4c710f9a8c627971fd5947acf44"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gadf48e4c710f9a8c627971fd5947acf44">arrow::is_base_binary_like</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gadf48e4c710f9a8c627971fd5947acf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a base-binary-like type.  <br /></td></tr>
<tr class="separator:gadf48e4c710f9a8c627971fd5947acf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c23f3fed7583d6bd9b59ba8272a287" id="r_gaf0c23f3fed7583d6bd9b59ba8272a287"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gaf0c23f3fed7583d6bd9b59ba8272a287">arrow::is_binary_like</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gaf0c23f3fed7583d6bd9b59ba8272a287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a binary-like type (i.e. with 32-bit offsets)  <br /></td></tr>
<tr class="separator:gaf0c23f3fed7583d6bd9b59ba8272a287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf54c34a56b4ea14b269790a059e34daa" id="r_gaf54c34a56b4ea14b269790a059e34daa"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gaf54c34a56b4ea14b269790a059e34daa">arrow::is_large_binary_like</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gaf54c34a56b4ea14b269790a059e34daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a large-binary-like type (i.e. with 64-bit offsets)  <br /></td></tr>
<tr class="separator:gaf54c34a56b4ea14b269790a059e34daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57e730064c490c5afb14a951d4386123" id="r_ga57e730064c490c5afb14a951d4386123"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga57e730064c490c5afb14a951d4386123">arrow::is_binary</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga57e730064c490c5afb14a951d4386123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a binary (non-string) type.  <br /></td></tr>
<tr class="separator:ga57e730064c490c5afb14a951d4386123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcbc23923cb79f29e5a22a995666d87" id="r_gaedcbc23923cb79f29e5a22a995666d87"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gaedcbc23923cb79f29e5a22a995666d87">arrow::is_string</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gaedcbc23923cb79f29e5a22a995666d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a string type.  <br /></td></tr>
<tr class="separator:gaedcbc23923cb79f29e5a22a995666d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34efc622cb78312205c42fcec8d34b17" id="r_ga34efc622cb78312205c42fcec8d34b17"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga34efc622cb78312205c42fcec8d34b17">arrow::is_binary_view_like</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga34efc622cb78312205c42fcec8d34b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a binary-view-like type (i.e. string view and binary view)  <br /></td></tr>
<tr class="separator:ga34efc622cb78312205c42fcec8d34b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23487791ae6fce89b8ddb474b44701f7" id="r_ga23487791ae6fce89b8ddb474b44701f7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga23487791ae6fce89b8ddb474b44701f7">arrow::is_temporal</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga23487791ae6fce89b8ddb474b44701f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a temporal type.  <br /></td></tr>
<tr class="separator:ga23487791ae6fce89b8ddb474b44701f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9d44ee1a0f0980a08315e5a11f145a" id="r_ga1f9d44ee1a0f0980a08315e5a11f145a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga1f9d44ee1a0f0980a08315e5a11f145a">arrow::is_time</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga1f9d44ee1a0f0980a08315e5a11f145a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a time type.  <br /></td></tr>
<tr class="separator:ga1f9d44ee1a0f0980a08315e5a11f145a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad13746a571e84e5cb9e298480e8505d5" id="r_gad13746a571e84e5cb9e298480e8505d5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gad13746a571e84e5cb9e298480e8505d5">arrow::is_date</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gad13746a571e84e5cb9e298480e8505d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a date type.  <br /></td></tr>
<tr class="separator:gad13746a571e84e5cb9e298480e8505d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba0fd0737f475a21c18a6a98eb9c7f2" id="r_gadba0fd0737f475a21c18a6a98eb9c7f2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gadba0fd0737f475a21c18a6a98eb9c7f2">arrow::is_interval</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gadba0fd0737f475a21c18a6a98eb9c7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an interval type.  <br /></td></tr>
<tr class="separator:gadba0fd0737f475a21c18a6a98eb9c7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f3bab2bf248adf43e3460d875f54c9" id="r_gaa3f3bab2bf248adf43e3460d875f54c9"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gaa3f3bab2bf248adf43e3460d875f54c9">arrow::is_dictionary</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gaa3f3bab2bf248adf43e3460d875f54c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a dictionary type.  <br /></td></tr>
<tr class="separator:gaa3f3bab2bf248adf43e3460d875f54c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206ea672a36dc554b04c6d4b72e03679" id="r_ga206ea672a36dc554b04c6d4b72e03679"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga206ea672a36dc554b04c6d4b72e03679">arrow::is_fixed_size_binary</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga206ea672a36dc554b04c6d4b72e03679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a fixed-size-binary type.  <br /></td></tr>
<tr class="separator:ga206ea672a36dc554b04c6d4b72e03679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab19b09453730938528ed2cbc19fae0b8" id="r_gab19b09453730938528ed2cbc19fae0b8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gab19b09453730938528ed2cbc19fae0b8">arrow::is_fixed_width</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gab19b09453730938528ed2cbc19fae0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a fixed-width type.  <br /></td></tr>
<tr class="separator:gab19b09453730938528ed2cbc19fae0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb695bf4cf5bf9a155549968d0f6b58" id="r_ga6fb695bf4cf5bf9a155549968d0f6b58"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga6fb695bf4cf5bf9a155549968d0f6b58">arrow::is_var_length_list</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga6fb695bf4cf5bf9a155549968d0f6b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a variable-length list type.  <br /></td></tr>
<tr class="separator:ga6fb695bf4cf5bf9a155549968d0f6b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1331df057712641fe5b6d4b7ba3370b1" id="r_ga1331df057712641fe5b6d4b7ba3370b1"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga1331df057712641fe5b6d4b7ba3370b1">arrow::is_list</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga1331df057712641fe5b6d4b7ba3370b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a list type.  <br /></td></tr>
<tr class="separator:ga1331df057712641fe5b6d4b7ba3370b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5c8946f6b7b84d8d577fd616f3aeae" id="r_gafc5c8946f6b7b84d8d577fd616f3aeae"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gafc5c8946f6b7b84d8d577fd616f3aeae">arrow::is_list_like</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gafc5c8946f6b7b84d8d577fd616f3aeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a list-like type.  <br /></td></tr>
<tr class="separator:gafc5c8946f6b7b84d8d577fd616f3aeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb26004e3b2dd9cc54afd63f06f6cd9f" id="r_gaeb26004e3b2dd9cc54afd63f06f6cd9f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gaeb26004e3b2dd9cc54afd63f06f6cd9f">arrow::is_var_length_list_like</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gaeb26004e3b2dd9cc54afd63f06f6cd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a var-length list or list-view like type.  <br /></td></tr>
<tr class="separator:gaeb26004e3b2dd9cc54afd63f06f6cd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2a1399d13289ed143ef1bb0e798c95" id="r_gaef2a1399d13289ed143ef1bb0e798c95"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gaef2a1399d13289ed143ef1bb0e798c95">arrow::is_list_view</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gaef2a1399d13289ed143ef1bb0e798c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a list-view type.  <br /></td></tr>
<tr class="separator:gaef2a1399d13289ed143ef1bb0e798c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabdc0eea73eca57ccb2780d3fa90a103" id="r_gaabdc0eea73eca57ccb2780d3fa90a103"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gaabdc0eea73eca57ccb2780d3fa90a103">arrow::is_nested</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:gaabdc0eea73eca57ccb2780d3fa90a103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a nested type.  <br /></td></tr>
<tr class="separator:gaabdc0eea73eca57ccb2780d3fa90a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89bc99047c0dfa98e1bf8967d2d2e964" id="r_ga89bc99047c0dfa98e1bf8967d2d2e964"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#ga89bc99047c0dfa98e1bf8967d2d2e964">arrow::is_union</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:ga89bc99047c0dfa98e1bf8967d2d2e964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a union type.  <br /></td></tr>
<tr class="separator:ga89bc99047c0dfa98e1bf8967d2d2e964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabad4fca6c6d133c7f758081c45617d4a" id="r_gabad4fca6c6d133c7f758081c45617d4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__runtime-type-predicates.html#gabad4fca6c6d133c7f758081c45617d4a">arrow::RequiredValueAlignmentForBuffer</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id, int buffer_index)</td></tr>
<tr class="memdesc:gabad4fca6c6d133c7f758081c45617d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the alignment a buffer should have to be considered "value aligned".  <br /></td></tr>
<tr class="separator:gabad4fca6c6d133c7f758081c45617d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadf48e4c710f9a8c627971fd5947acf44" name="gadf48e4c710f9a8c627971fd5947acf44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf48e4c710f9a8c627971fd5947acf44">&#9670;&#160;</a></span>is_base_binary_like()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_base_binary_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a base-binary-like type. </p>
<p>This predicate doesn't match fixed-size binary types and will otherwise match all binary- and string-like types regardless of offset width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a base-binary-like type one </dd></dl>

</div>
</div>
<a id="ga57e730064c490c5afb14a951d4386123" name="ga57e730064c490c5afb14a951d4386123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57e730064c490c5afb14a951d4386123">&#9670;&#160;</a></span>is_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a binary (non-string) type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a binary type one </dd></dl>

</div>
</div>
<a id="gaf0c23f3fed7583d6bd9b59ba8272a287" name="gaf0c23f3fed7583d6bd9b59ba8272a287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c23f3fed7583d6bd9b59ba8272a287">&#9670;&#160;</a></span>is_binary_like()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_binary_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a binary-like type (i.e. with 32-bit offsets) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a binary-like type one </dd></dl>

</div>
</div>
<a id="ga34efc622cb78312205c42fcec8d34b17" name="ga34efc622cb78312205c42fcec8d34b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34efc622cb78312205c42fcec8d34b17">&#9670;&#160;</a></span>is_binary_view_like()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_binary_view_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a binary-view-like type (i.e. string view and binary view) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a binary-view-like type one </dd></dl>

</div>
</div>
<a id="gad13746a571e84e5cb9e298480e8505d5" name="gad13746a571e84e5cb9e298480e8505d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad13746a571e84e5cb9e298480e8505d5">&#9670;&#160;</a></span>is_date()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_date </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a date type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a primitive type one </dd></dl>

</div>
</div>
<a id="ga9b7ace06bd99e8890324051b28316e53" name="ga9b7ace06bd99e8890324051b28316e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b7ace06bd99e8890324051b28316e53">&#9670;&#160;</a></span>is_decimal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_decimal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a decimal type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a decimal type one </dd></dl>

</div>
</div>
<a id="gaa3f3bab2bf248adf43e3460d875f54c9" name="gaa3f3bab2bf248adf43e3460d875f54c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3f3bab2bf248adf43e3460d875f54c9">&#9670;&#160;</a></span>is_dictionary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a dictionary type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a dictionary type one </dd></dl>

</div>
</div>
<a id="ga206ea672a36dc554b04c6d4b72e03679" name="ga206ea672a36dc554b04c6d4b72e03679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga206ea672a36dc554b04c6d4b72e03679">&#9670;&#160;</a></span>is_fixed_size_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_fixed_size_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a fixed-size-binary type. </p>
<p>This predicate also matches decimals. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a fixed-size-binary type one </dd></dl>

</div>
</div>
<a id="gab19b09453730938528ed2cbc19fae0b8" name="gab19b09453730938528ed2cbc19fae0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab19b09453730938528ed2cbc19fae0b8">&#9670;&#160;</a></span>is_fixed_width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_fixed_width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a fixed-width type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a fixed-width type one </dd></dl>

</div>
</div>
<a id="ga54aa5d70bb3008ffd838f2c37a9586a5" name="ga54aa5d70bb3008ffd838f2c37a9586a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54aa5d70bb3008ffd838f2c37a9586a5">&#9670;&#160;</a></span>is_floating()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_floating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a floating point type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a floating point type one </dd></dl>

</div>
</div>
<a id="ga2aef37f781085bfbfe78b44c6110d089" name="ga2aef37f781085bfbfe78b44c6110d089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aef37f781085bfbfe78b44c6110d089">&#9670;&#160;</a></span>is_integer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for an integer type (signed or unsigned) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is an integer type one </dd></dl>

</div>
</div>
<a id="gadba0fd0737f475a21c18a6a98eb9c7f2" name="gadba0fd0737f475a21c18a6a98eb9c7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadba0fd0737f475a21c18a6a98eb9c7f2">&#9670;&#160;</a></span>is_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for an interval type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is an interval type one </dd></dl>

</div>
</div>
<a id="gaf54c34a56b4ea14b269790a059e34daa" name="gaf54c34a56b4ea14b269790a059e34daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf54c34a56b4ea14b269790a059e34daa">&#9670;&#160;</a></span>is_large_binary_like()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_large_binary_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a large-binary-like type (i.e. with 64-bit offsets) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a large-binary-like type one </dd></dl>

</div>
</div>
<a id="ga1331df057712641fe5b6d4b7ba3370b1" name="ga1331df057712641fe5b6d4b7ba3370b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1331df057712641fe5b6d4b7ba3370b1">&#9670;&#160;</a></span>is_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a list type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a list type one </dd></dl>

</div>
</div>
<a id="gafc5c8946f6b7b84d8d577fd616f3aeae" name="gafc5c8946f6b7b84d8d577fd616f3aeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc5c8946f6b7b84d8d577fd616f3aeae">&#9670;&#160;</a></span>is_list_like()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_list_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a list-like type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a list-like type one </dd></dl>

</div>
</div>
<a id="gaef2a1399d13289ed143ef1bb0e798c95" name="gaef2a1399d13289ed143ef1bb0e798c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef2a1399d13289ed143ef1bb0e798c95">&#9670;&#160;</a></span>is_list_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_list_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a list-view type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a list-view type one </dd></dl>

</div>
</div>
<a id="gaabdc0eea73eca57ccb2780d3fa90a103" name="gaabdc0eea73eca57ccb2780d3fa90a103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabdc0eea73eca57ccb2780d3fa90a103">&#9670;&#160;</a></span>is_nested()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_nested </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a nested type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a nested type one </dd></dl>

</div>
</div>
<a id="ga049e542444b7d2f87dd06331485a5bea" name="ga049e542444b7d2f87dd06331485a5bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga049e542444b7d2f87dd06331485a5bea">&#9670;&#160;</a></span>is_numeric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_numeric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a numeric type. </p>
<p>This predicate doesn't match decimals (see <code>is_decimal</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a numeric type one </dd></dl>

</div>
</div>
<a id="gaf640ac17b8c546ca403580f01a65b82c" name="gaf640ac17b8c546ca403580f01a65b82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf640ac17b8c546ca403580f01a65b82c">&#9670;&#160;</a></span>is_primitive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_primitive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a primitive type. </p>
<p>This predicate doesn't match null, decimals and binary-like types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a primitive type one </dd></dl>

</div>
</div>
<a id="gaf4905eeda5e969c2f166c4e420cd1f87" name="gaf4905eeda5e969c2f166c4e420cd1f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4905eeda5e969c2f166c4e420cd1f87">&#9670;&#160;</a></span>is_run_end_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_run_end_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a type that can be used as a run-end in Run-End Encoded arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id can represent a run-end value </dd></dl>

</div>
</div>
<a id="ga4124c6de5880daeacfed37da75c576e4" name="ga4124c6de5880daeacfed37da75c576e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4124c6de5880daeacfed37da75c576e4">&#9670;&#160;</a></span>is_signed_integer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_signed_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a signed integer type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a signed integer type one </dd></dl>

</div>
</div>
<a id="gaedcbc23923cb79f29e5a22a995666d87" name="gaedcbc23923cb79f29e5a22a995666d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedcbc23923cb79f29e5a22a995666d87">&#9670;&#160;</a></span>is_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a string type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a string type one </dd></dl>

</div>
</div>
<a id="ga23487791ae6fce89b8ddb474b44701f7" name="ga23487791ae6fce89b8ddb474b44701f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23487791ae6fce89b8ddb474b44701f7">&#9670;&#160;</a></span>is_temporal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_temporal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a temporal type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a temporal type one </dd></dl>

</div>
</div>
<a id="ga1f9d44ee1a0f0980a08315e5a11f145a" name="ga1f9d44ee1a0f0980a08315e5a11f145a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f9d44ee1a0f0980a08315e5a11f145a">&#9670;&#160;</a></span>is_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a time type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a primitive type one </dd></dl>

</div>
</div>
<a id="ga89bc99047c0dfa98e1bf8967d2d2e964" name="ga89bc99047c0dfa98e1bf8967d2d2e964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89bc99047c0dfa98e1bf8967d2d2e964">&#9670;&#160;</a></span>is_union()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a union type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a union type one </dd></dl>

</div>
</div>
<a id="ga0eefa3fccb703148e2a8b70c632e89fa" name="ga0eefa3fccb703148e2a8b70c632e89fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eefa3fccb703148e2a8b70c632e89fa">&#9670;&#160;</a></span>is_unsigned_integer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_unsigned_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for an unsigned integer type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is an unsigned integer type one </dd></dl>

</div>
</div>
<a id="ga6fb695bf4cf5bf9a155549968d0f6b58" name="ga6fb695bf4cf5bf9a155549968d0f6b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fb695bf4cf5bf9a155549968d0f6b58">&#9670;&#160;</a></span>is_var_length_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_var_length_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a variable-length list type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a variable-length list type one </dd></dl>

</div>
</div>
<a id="gaeb26004e3b2dd9cc54afd63f06f6cd9f" name="gaeb26004e3b2dd9cc54afd63f06f6cd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb26004e3b2dd9cc54afd63f06f6cd9f">&#9670;&#160;</a></span>is_var_length_list_like()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool arrow::is_var_length_list_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for a var-length list or list-view like type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_id</td><td>the type-id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether type-id is a var-length list or list-view like type </dd></dl>

</div>
</div>
<a id="gabad4fca6c6d133c7f758081c45617d4a" name="gabad4fca6c6d133c7f758081c45617d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabad4fca6c6d133c7f758081c45617d4a">&#9670;&#160;</a></span>RequiredValueAlignmentForBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::RequiredValueAlignmentForBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a>&#160;</td>
          <td class="paramname"><em>type_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the alignment a buffer should have to be considered "value aligned". </p>
<p>Some buffers are frequently type-punned. For example, in an int32 array the values buffer is frequently cast to int32_t*</p>
<p>This sort of punning is technically only valid if the pointer is aligned to a proper width (e.g. 4 bytes in the case of int32). However, most modern compilers are quite permissive if we get this wrong. Note that this alignment is something that is guaranteed by malloc (e.g. new int32_t[] will return a buffer that is 4 byte aligned) or common libraries (e.g. numpy) but it is not currently guaranteed by flight (GH-32276).</p>
<p>We call this "value aligned" and this method will calculate that required alignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_id</td><td>the type of the array containing the buffer Note: this should be the indices type for a dictionary array since A dictionary array's buffers are indices. It should be the storage type for an extension array. </td></tr>
    <tr><td class="paramname">buffer_index</td><td>the index of the buffer to check, for example 0 will typically give you the alignment expected of the validity buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the required value alignment in bytes (1 if no alignment required) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
