<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visualization of data from MMS: ConcatenateTables function.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Visualization of data from MMS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">ConcatenateTables function.</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacearrow_1_1compute" id="r_namespacearrow_1_1compute"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html">arrow::compute</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1ConcatenateTablesOptions.html">arrow::ConcatenateTablesOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the behavior of <a class="el" href="group__concat-tables.html#ga810b64cf732804b1f524164de7228c8e" title="Construct a new table from multiple input tables.">ConcatenateTables()</a>.  <a href="structarrow_1_1ConcatenateTablesOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7ea1eed4818941b9b1eb98381e1b9690" id="r_ga7ea1eed4818941b9b1eb98381e1b9690"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga7ea1eed4818941b9b1eb98381e1b9690">arrow::Table::~Table</a> ()=default</td></tr>
<tr class="separator:ga7ea1eed4818941b9b1eb98381e1b9690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00e2717baa0a3984c094d84b46f3eb5" id="r_gab00e2717baa0a3984c094d84b46f3eb5"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gab00e2717baa0a3984c094d84b46f3eb5">arrow::Table::Make</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; <a class="el" href="group__concat-tables.html#ga0bbc06883035a8b88f8a88ee0d458cfe">schema</a>, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt; &gt; <a class="el" href="group__concat-tables.html#gab92a98dffc6c50aa917169edb8dd337b">columns</a>, int64_t <a class="el" href="group__concat-tables.html#ga14665d44a57c45343b54c7997d5c92e5">num_rows</a>=-1)</td></tr>
<tr class="memdesc:gab00e2717baa0a3984c094d84b46f3eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from schema and columns.  <br /></td></tr>
<tr class="separator:gab00e2717baa0a3984c094d84b46f3eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a7b2c852c93db11d9b1fda4665a88c7" id="r_ga4a7b2c852c93db11d9b1fda4665a88c7"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga4a7b2c852c93db11d9b1fda4665a88c7">arrow::Table::Make</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; <a class="el" href="group__concat-tables.html#ga0bbc06883035a8b88f8a88ee0d458cfe">schema</a>, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Array.html">Array</a> &gt; &gt; &amp;arrays, int64_t <a class="el" href="group__concat-tables.html#ga14665d44a57c45343b54c7997d5c92e5">num_rows</a>=-1)</td></tr>
<tr class="memdesc:ga4a7b2c852c93db11d9b1fda4665a88c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from schema and arrays.  <br /></td></tr>
<tr class="separator:ga4a7b2c852c93db11d9b1fda4665a88c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ea65f8560c837132f8aac8a2f755f3" id="r_gad4ea65f8560c837132f8aac8a2f755f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gad4ea65f8560c837132f8aac8a2f755f3">arrow::Table::MakeEmpty</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; <a class="el" href="group__concat-tables.html#ga0bbc06883035a8b88f8a88ee0d458cfe">schema</a>, <a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *pool=<a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>())</td></tr>
<tr class="memdesc:gad4ea65f8560c837132f8aac8a2f755f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> of a given schema.  <br /></td></tr>
<tr class="separator:gad4ea65f8560c837132f8aac8a2f755f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e64d42ab6c95df2cd0f967a62ae2dc5" id="r_ga8e64d42ab6c95df2cd0f967a62ae2dc5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga8e64d42ab6c95df2cd0f967a62ae2dc5">arrow::Table::FromRecordBatchReader</a> (<a class="el" href="classarrow_1_1RecordBatchReader.html">RecordBatchReader</a> *reader)</td></tr>
<tr class="memdesc:ga8e64d42ab6c95df2cd0f967a62ae2dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from a <a class="el" href="classarrow_1_1RecordBatchReader.html" title="Abstract interface for reading stream of record batches.">RecordBatchReader</a>.  <br /></td></tr>
<tr class="separator:ga8e64d42ab6c95df2cd0f967a62ae2dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa06cb917a909a30efd28aca46dd7ede3" id="r_gaa06cb917a909a30efd28aca46dd7ede3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gaa06cb917a909a30efd28aca46dd7ede3">arrow::Table::FromRecordBatches</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1RecordBatch.html">RecordBatch</a> &gt; &gt; &amp;batches)</td></tr>
<tr class="memdesc:gaa06cb917a909a30efd28aca46dd7ede3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from RecordBatches, using schema supplied by the first <a class="el" href="classarrow_1_1RecordBatch.html" title="Collection of equal-length arrays matching a particular Schema.">RecordBatch</a>.  <br /></td></tr>
<tr class="separator:gaa06cb917a909a30efd28aca46dd7ede3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf783ad6e12e7c71507ce957c76717251" id="r_gaf783ad6e12e7c71507ce957c76717251"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gaf783ad6e12e7c71507ce957c76717251">arrow::Table::FromRecordBatches</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; <a class="el" href="group__concat-tables.html#ga0bbc06883035a8b88f8a88ee0d458cfe">schema</a>, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1RecordBatch.html">RecordBatch</a> &gt; &gt; &amp;batches)</td></tr>
<tr class="memdesc:gaf783ad6e12e7c71507ce957c76717251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from RecordBatches, using supplied schema. There may be zero record batches.  <br /></td></tr>
<tr class="separator:gaf783ad6e12e7c71507ce957c76717251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8557289f578577b2d87aafbbfb96a005" id="r_ga8557289f578577b2d87aafbbfb96a005"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga8557289f578577b2d87aafbbfb96a005">arrow::Table::FromChunkedStructArray</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt; &amp;array)</td></tr>
<tr class="memdesc:ga8557289f578577b2d87aafbbfb96a005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from a chunked <a class="el" href="classarrow_1_1StructArray.html" title="Concrete Array class for struct data.">StructArray</a>. One column will be produced for each field of the <a class="el" href="classarrow_1_1StructArray.html" title="Concrete Array class for struct data.">StructArray</a>.  <br /></td></tr>
<tr class="separator:ga8557289f578577b2d87aafbbfb96a005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bbc06883035a8b88f8a88ee0d458cfe" id="r_ga0bbc06883035a8b88f8a88ee0d458cfe"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga0bbc06883035a8b88f8a88ee0d458cfe">arrow::Table::schema</a> () const</td></tr>
<tr class="memdesc:ga0bbc06883035a8b88f8a88ee0d458cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the table schema.  <br /></td></tr>
<tr class="separator:ga0bbc06883035a8b88f8a88ee0d458cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga703109f368661d948d57d58981b92ea1" id="r_ga703109f368661d948d57d58981b92ea1"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga703109f368661d948d57d58981b92ea1">arrow::Table::column</a> (int i) const =0</td></tr>
<tr class="memdesc:ga703109f368661d948d57d58981b92ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column by index.  <br /></td></tr>
<tr class="separator:ga703109f368661d948d57d58981b92ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab92a98dffc6c50aa917169edb8dd337b" id="r_gab92a98dffc6c50aa917169edb8dd337b"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gab92a98dffc6c50aa917169edb8dd337b">arrow::Table::columns</a> () const =0</td></tr>
<tr class="memdesc:gab92a98dffc6c50aa917169edb8dd337b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector of all columns for table.  <br /></td></tr>
<tr class="separator:gab92a98dffc6c50aa917169edb8dd337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4222aea770ec19e0ce6769298c488619" id="r_ga4222aea770ec19e0ce6769298c488619"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Field.html">Field</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga4222aea770ec19e0ce6769298c488619">arrow::Table::field</a> (int i) const</td></tr>
<tr class="memdesc:ga4222aea770ec19e0ce6769298c488619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column's field by index.  <br /></td></tr>
<tr class="separator:ga4222aea770ec19e0ce6769298c488619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b9844bc25861874e7eefd7b513d7c1" id="r_ga90b9844bc25861874e7eefd7b513d7c1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Field.html">Field</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga90b9844bc25861874e7eefd7b513d7c1">arrow::Table::fields</a> () const</td></tr>
<tr class="memdesc:ga90b9844bc25861874e7eefd7b513d7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector of all fields for table.  <br /></td></tr>
<tr class="separator:ga90b9844bc25861874e7eefd7b513d7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9d82d5fc1335373b5586816a698d75" id="r_gaaa9d82d5fc1335373b5586816a698d75"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gaaa9d82d5fc1335373b5586816a698d75">arrow::Table::Slice</a> (int64_t offset, int64_t length) const =0</td></tr>
<tr class="memdesc:gaaa9d82d5fc1335373b5586816a698d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-copy slice of the table with the indicated offset and length.  <br /></td></tr>
<tr class="separator:gaaa9d82d5fc1335373b5586816a698d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c432da346faaccb0ed8fccd4188d62" id="r_gae9c432da346faaccb0ed8fccd4188d62"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gae9c432da346faaccb0ed8fccd4188d62">arrow::Table::Slice</a> (int64_t offset) const</td></tr>
<tr class="memdesc:gae9c432da346faaccb0ed8fccd4188d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice from first row at offset until end of the table.  <br /></td></tr>
<tr class="separator:gae9c432da346faaccb0ed8fccd4188d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac391f5d54cf24a7c57b592eb588b681b" id="r_gac391f5d54cf24a7c57b592eb588b681b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gac391f5d54cf24a7c57b592eb588b681b">arrow::Table::GetColumnByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:gac391f5d54cf24a7c57b592eb588b681b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column by name.  <br /></td></tr>
<tr class="separator:gac391f5d54cf24a7c57b592eb588b681b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec96eb75d66e8a6bfdc117331587aff" id="r_ga6ec96eb75d66e8a6bfdc117331587aff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga6ec96eb75d66e8a6bfdc117331587aff">arrow::Table::RemoveColumn</a> (int i) const =0</td></tr>
<tr class="memdesc:ga6ec96eb75d66e8a6bfdc117331587aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove column from the table, producing a new <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a>.  <br /></td></tr>
<tr class="separator:ga6ec96eb75d66e8a6bfdc117331587aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c883b489d893f798442fc0d536ff2f4" id="r_ga5c883b489d893f798442fc0d536ff2f4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga5c883b489d893f798442fc0d536ff2f4">arrow::Table::AddColumn</a> (int i, std::shared_ptr&lt; <a class="el" href="classarrow_1_1Field.html">Field</a> &gt; field_arg, std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt; <a class="el" href="group__concat-tables.html#ga703109f368661d948d57d58981b92ea1">column</a>) const =0</td></tr>
<tr class="memdesc:ga5c883b489d893f798442fc0d536ff2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add column to the table, producing a new <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a>.  <br /></td></tr>
<tr class="separator:ga5c883b489d893f798442fc0d536ff2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3641d03292b554c9fce50fef40a5c2e1" id="r_ga3641d03292b554c9fce50fef40a5c2e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga3641d03292b554c9fce50fef40a5c2e1">arrow::Table::SetColumn</a> (int i, std::shared_ptr&lt; <a class="el" href="classarrow_1_1Field.html">Field</a> &gt; field_arg, std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt; <a class="el" href="group__concat-tables.html#ga703109f368661d948d57d58981b92ea1">column</a>) const =0</td></tr>
<tr class="memdesc:ga3641d03292b554c9fce50fef40a5c2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a column in the table, producing a new <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a>.  <br /></td></tr>
<tr class="separator:ga3641d03292b554c9fce50fef40a5c2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07483f91b16857362f44d32129c9c10" id="r_gaf07483f91b16857362f44d32129c9c10"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gaf07483f91b16857362f44d32129c9c10">arrow::Table::ColumnNames</a> () const</td></tr>
<tr class="memdesc:gaf07483f91b16857362f44d32129c9c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return names of all columns.  <br /></td></tr>
<tr class="separator:gaf07483f91b16857362f44d32129c9c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga786fe8fe5b6982e14c7956cb763e8729" id="r_ga786fe8fe5b6982e14c7956cb763e8729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga786fe8fe5b6982e14c7956cb763e8729">arrow::Table::RenameColumns</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ga786fe8fe5b6982e14c7956cb763e8729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename columns with provided names.  <br /></td></tr>
<tr class="separator:ga786fe8fe5b6982e14c7956cb763e8729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c009f45658bcef2bed8f68292057d0d" id="r_ga9c009f45658bcef2bed8f68292057d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga9c009f45658bcef2bed8f68292057d0d">arrow::Table::SelectColumns</a> (const std::vector&lt; int &gt; &amp;indices) const</td></tr>
<tr class="memdesc:ga9c009f45658bcef2bed8f68292057d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return new table with specified columns.  <br /></td></tr>
<tr class="separator:ga9c009f45658bcef2bed8f68292057d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c4b17f00875e481b5df75aec60f54f" id="r_gae8c4b17f00875e481b5df75aec60f54f"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gae8c4b17f00875e481b5df75aec60f54f">arrow::Table::ReplaceSchemaMetadata</a> (const std::shared_ptr&lt; const <a class="el" href="classarrow_1_1KeyValueMetadata.html">KeyValueMetadata</a> &gt; &amp;metadata) const =0</td></tr>
<tr class="memdesc:gae8c4b17f00875e481b5df75aec60f54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace schema key-value metadata with new metadata.  <br /></td></tr>
<tr class="separator:gae8c4b17f00875e481b5df75aec60f54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fbb47dde07154f9940859028341d712" id="r_ga6fbb47dde07154f9940859028341d712"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga6fbb47dde07154f9940859028341d712">arrow::Table::Flatten</a> (<a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *pool=<a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>()) const =0</td></tr>
<tr class="memdesc:ga6fbb47dde07154f9940859028341d712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten the table, producing a new <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a>. Any column with a struct type will be flattened into multiple columns.  <br /></td></tr>
<tr class="separator:ga6fbb47dde07154f9940859028341d712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952001529c848c932349b3198d98b680" id="r_ga952001529c848c932349b3198d98b680"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga952001529c848c932349b3198d98b680">arrow::Table::ToString</a> () const</td></tr>
<tr class="separator:ga952001529c848c932349b3198d98b680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a93ccc812c7ee9992bc9138b53895e0" id="r_ga4a93ccc812c7ee9992bc9138b53895e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga4a93ccc812c7ee9992bc9138b53895e0">arrow::Table::Validate</a> () const =0</td></tr>
<tr class="memdesc:ga4a93ccc812c7ee9992bc9138b53895e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform cheap validation checks to determine obvious inconsistencies within the table's schema and internal data.  <br /></td></tr>
<tr class="separator:ga4a93ccc812c7ee9992bc9138b53895e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5796527d5848794aff9b6b3107011dd7" id="r_ga5796527d5848794aff9b6b3107011dd7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga5796527d5848794aff9b6b3107011dd7">arrow::Table::ValidateFull</a> () const =0</td></tr>
<tr class="memdesc:ga5796527d5848794aff9b6b3107011dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform extensive validation checks to determine inconsistencies within the table's schema and internal data.  <br /></td></tr>
<tr class="separator:ga5796527d5848794aff9b6b3107011dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe71e003123973cdff9cfca40dc85e04" id="r_gabe71e003123973cdff9cfca40dc85e04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gabe71e003123973cdff9cfca40dc85e04">arrow::Table::num_columns</a> () const</td></tr>
<tr class="memdesc:gabe71e003123973cdff9cfca40dc85e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of columns in the table.  <br /></td></tr>
<tr class="separator:gabe71e003123973cdff9cfca40dc85e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14665d44a57c45343b54c7997d5c92e5" id="r_ga14665d44a57c45343b54c7997d5c92e5"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga14665d44a57c45343b54c7997d5c92e5">arrow::Table::num_rows</a> () const</td></tr>
<tr class="memdesc:ga14665d44a57c45343b54c7997d5c92e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of rows (equal to each column's logical length)  <br /></td></tr>
<tr class="separator:ga14665d44a57c45343b54c7997d5c92e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc19bf0d1bcd8234e62d6dbce93e643b" id="r_gadc19bf0d1bcd8234e62d6dbce93e643b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gadc19bf0d1bcd8234e62d6dbce93e643b">arrow::Table::Equals</a> (const <a class="el" href="classarrow_1_1Table.html">Table</a> &amp;other, bool check_metadata=false) const</td></tr>
<tr class="memdesc:gadc19bf0d1bcd8234e62d6dbce93e643b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if tables are equal.  <br /></td></tr>
<tr class="separator:gadc19bf0d1bcd8234e62d6dbce93e643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a84bfbd4c2112e179ec0624114f0d9" id="r_gab2a84bfbd4c2112e179ec0624114f0d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gab2a84bfbd4c2112e179ec0624114f0d9">arrow::Table::CombineChunks</a> (<a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *pool=<a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>()) const</td></tr>
<tr class="memdesc:gab2a84bfbd4c2112e179ec0624114f0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new table by combining the chunks this table has.  <br /></td></tr>
<tr class="separator:gab2a84bfbd4c2112e179ec0624114f0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c249477d4aed2cb438828754183edb" id="r_ga89c249477d4aed2cb438828754183edb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1RecordBatch.html">RecordBatch</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga89c249477d4aed2cb438828754183edb">arrow::Table::CombineChunksToBatch</a> (<a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *pool=<a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>()) const</td></tr>
<tr class="memdesc:ga89c249477d4aed2cb438828754183edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new record batch by combining the chunks this table has.  <br /></td></tr>
<tr class="separator:ga89c249477d4aed2cb438828754183edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd70d5a21ef0558472d6e594d3ceeb2" id="r_gaebd70d5a21ef0558472d6e594d3ceeb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gaebd70d5a21ef0558472d6e594d3ceeb2">arrow::Table::Table</a> ()</td></tr>
<tr class="separator:gaebd70d5a21ef0558472d6e594d3ceeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae1034b4c522d66da02ac1e17f30195" id="r_ga4ae1034b4c522d66da02ac1e17f30195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga4ae1034b4c522d66da02ac1e17f30195">arrow::TableBatchReader::TableBatchReader</a> (const <a class="el" href="classarrow_1_1Table.html">Table</a> &amp;table)</td></tr>
<tr class="memdesc:ga4ae1034b4c522d66da02ac1e17f30195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1TableBatchReader.html" title="Compute a stream of record batches from a (possibly chunked) Table.">TableBatchReader</a> for the given table.  <br /></td></tr>
<tr class="separator:ga4ae1034b4c522d66da02ac1e17f30195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cfa28fb14217b6e9b82ea34e646b596" id="r_ga0cfa28fb14217b6e9b82ea34e646b596"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga0cfa28fb14217b6e9b82ea34e646b596">arrow::TableBatchReader::TableBatchReader</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; table)</td></tr>
<tr class="separator:ga0cfa28fb14217b6e9b82ea34e646b596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a97ebc32f740b0ec93b0bfe1ba73aa2" id="r_ga0a97ebc32f740b0ec93b0bfe1ba73aa2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga0a97ebc32f740b0ec93b0bfe1ba73aa2">arrow::TableBatchReader::schema</a> () const override</td></tr>
<tr class="separator:ga0a97ebc32f740b0ec93b0bfe1ba73aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d001eabe7404ee8e3d7a568eae0e93" id="r_ga31d001eabe7404ee8e3d7a568eae0e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga31d001eabe7404ee8e3d7a568eae0e93">arrow::TableBatchReader::ReadNext</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1RecordBatch.html">RecordBatch</a> &gt; *out) override</td></tr>
<tr class="memdesc:ga31d001eabe7404ee8e3d7a568eae0e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next record batch in the stream. Return null for batch when reaching end of stream.  <br /></td></tr>
<tr class="separator:ga31d001eabe7404ee8e3d7a568eae0e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293c77d9e315f264bc84e770d357b089" id="r_ga293c77d9e315f264bc84e770d357b089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga293c77d9e315f264bc84e770d357b089">arrow::TableBatchReader::set_chunksize</a> (int64_t chunksize)</td></tr>
<tr class="memdesc:ga293c77d9e315f264bc84e770d357b089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the desired maximum number of rows for record batches.  <br /></td></tr>
<tr class="separator:ga293c77d9e315f264bc84e770d357b089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f99414177f1507f6efa3471cb650bbb" id="r_ga1f99414177f1507f6efa3471cb650bbb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structarrow_1_1ConcatenateTablesOptions.html">ConcatenateTablesOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga1f99414177f1507f6efa3471cb650bbb">arrow::ConcatenateTablesOptions::Defaults</a> ()</td></tr>
<tr class="separator:ga1f99414177f1507f6efa3471cb650bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga810b64cf732804b1f524164de7228c8e" id="r_ga810b64cf732804b1f524164de7228c8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga810b64cf732804b1f524164de7228c8e">arrow::ConcatenateTables</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; &amp;tables, <a class="el" href="structarrow_1_1ConcatenateTablesOptions.html">ConcatenateTablesOptions</a> options=<a class="el" href="group__concat-tables.html#ga1f99414177f1507f6efa3471cb650bbb">ConcatenateTablesOptions::Defaults</a>(), <a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *memory_pool=<a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>())</td></tr>
<tr class="memdesc:ga810b64cf732804b1f524164de7228c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new table from multiple input tables.  <br /></td></tr>
<tr class="separator:ga810b64cf732804b1f524164de7228c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b413e09909285c4bec08ac6e9a1fa0" id="r_gae7b413e09909285c4bec08ac6e9a1fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gae7b413e09909285c4bec08ac6e9a1fa0">arrow::PromoteTableToSchema</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &amp;table, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; &amp;<a class="el" href="group__schema-factories.html#ga032cd7b83f6ffb87ca1f418dad5f4095">schema</a>, <a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *pool=<a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>())</td></tr>
<tr class="memdesc:gae7b413e09909285c4bec08ac6e9a1fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes a table to conform to the given schema.  <br /></td></tr>
<tr class="separator:gae7b413e09909285c4bec08ac6e9a1fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c477f7b61f120f856711407bbd6683b" id="r_ga1c477f7b61f120f856711407bbd6683b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga1c477f7b61f120f856711407bbd6683b">arrow::PromoteTableToSchema</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &amp;table, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; &amp;<a class="el" href="group__schema-factories.html#ga032cd7b83f6ffb87ca1f418dad5f4095">schema</a>, const <a class="el" href="classarrow_1_1compute_1_1CastOptions.html">compute::CastOptions</a> &amp;options, <a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *pool=<a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>())</td></tr>
<tr class="memdesc:ga1c477f7b61f120f856711407bbd6683b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes a table to conform to the given schema.  <br /></td></tr>
<tr class="separator:ga1c477f7b61f120f856711407bbd6683b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga40375f7767ae6caea748d87e53aacb45" id="r_ga40375f7767ae6caea748d87e53aacb45"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga40375f7767ae6caea748d87e53aacb45">arrow::Table::schema_</a></td></tr>
<tr class="separator:ga40375f7767ae6caea748d87e53aacb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7b895c038e468dac1be8d27722ffa6" id="r_ga7b7b895c038e468dac1be8d27722ffa6"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga7b7b895c038e468dac1be8d27722ffa6">arrow::Table::num_rows_</a></td></tr>
<tr class="separator:ga7b7b895c038e468dac1be8d27722ffa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c26f51a3023e3bc2eb6ae5a4510a9a" id="r_gac7c26f51a3023e3bc2eb6ae5a4510a9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gac7c26f51a3023e3bc2eb6ae5a4510a9a">arrow::ConcatenateTablesOptions::unify_schemas</a> = false</td></tr>
<tr class="separator:gac7c26f51a3023e3bc2eb6ae5a4510a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20181bbcd6ae25ba49cadf11c636d4b3" id="r_ga20181bbcd6ae25ba49cadf11c636d4b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarrow_1_1Field_1_1MergeOptions.html">Field::MergeOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga20181bbcd6ae25ba49cadf11c636d4b3">arrow::ConcatenateTablesOptions::field_merge_options</a> = <a class="el" href="structarrow_1_1Field_1_1MergeOptions.html#aad6ec10fe86793101bf688bbf9c9ad96">Field::MergeOptions::Defaults</a>()</td></tr>
<tr class="separator:ga20181bbcd6ae25ba49cadf11c636d4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>ConcatenateTables function. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5c883b489d893f798442fc0d536ff2f4" name="ga5c883b489d893f798442fc0d536ff2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c883b489d893f798442fc0d536ff2f4">&#9670;&#160;</a></span>AddColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::AddColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Field.html">Field</a> &gt;&#160;</td>
          <td class="paramname"><em>field_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt;&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add column to the table, producing a new <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a>. </p>

</div>
</div>
<a id="ga703109f368661d948d57d58981b92ea1" name="ga703109f368661d948d57d58981b92ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga703109f368661d948d57d58981b92ea1">&#9670;&#160;</a></span>column()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt; arrow::Table::column </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column by index. </p>

</div>
</div>
<a id="gaf07483f91b16857362f44d32129c9c10" name="gaf07483f91b16857362f44d32129c9c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf07483f91b16857362f44d32129c9c10">&#9670;&#160;</a></span>ColumnNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; arrow::Table::ColumnNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return names of all columns. </p>

</div>
</div>
<a id="gab92a98dffc6c50aa917169edb8dd337b" name="gab92a98dffc6c50aa917169edb8dd337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab92a98dffc6c50aa917169edb8dd337b">&#9670;&#160;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt; &gt; &amp; arrow::Table::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return vector of all columns for table. </p>

</div>
</div>
<a id="gab2a84bfbd4c2112e179ec0624114f0d9" name="gab2a84bfbd4c2112e179ec0624114f0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2a84bfbd4c2112e179ec0624114f0d9">&#9670;&#160;</a></span>CombineChunks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::CombineChunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a new table by combining the chunks this table has. </p>
<p>All the underlying chunks in the <a class="el" href="classarrow_1_1ChunkedArray.html" title="A data structure managing a list of primitive Arrow arrays logically as one large array.">ChunkedArray</a> of each column are concatenated into zero or one chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The pool for buffer allocations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89c249477d4aed2cb438828754183edb" name="ga89c249477d4aed2cb438828754183edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89c249477d4aed2cb438828754183edb">&#9670;&#160;</a></span>CombineChunksToBatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1RecordBatch.html">RecordBatch</a> &gt; &gt; arrow::Table::CombineChunksToBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a new record batch by combining the chunks this table has. </p>
<p>All the underlying chunks in the <a class="el" href="classarrow_1_1ChunkedArray.html" title="A data structure managing a list of primitive Arrow arrays logically as one large array.">ChunkedArray</a> of each column are concatenated into a single chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The pool for buffer allocations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga810b64cf732804b1f524164de7228c8e" name="ga810b64cf732804b1f524164de7228c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga810b64cf732804b1f524164de7228c8e">&#9670;&#160;</a></span>ConcatenateTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::ConcatenateTables </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1ConcatenateTablesOptions.html">ConcatenateTablesOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="group__concat-tables.html#ga1f99414177f1507f6efa3471cb650bbb">ConcatenateTablesOptions::Defaults</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>memory_pool</em> = <code><a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new table from multiple input tables. </p>
<p>The new table is assembled from existing column chunks without copying, if schemas are identical. If schemas do not match exactly and unify_schemas is enabled in options (off by default), an attempt is made to unify them, and then column chunks are converted to their respective unified datatype, which will probably incur a copy. :func:<code><a class="el" href="group__concat-tables.html#gae7b413e09909285c4bec08ac6e9a1fa0" title="Promotes a table to conform to the given schema.">arrow::PromoteTableToSchema</a></code> is used to unify schemas.</p>
<p>Tables are concatenated in order they are provided in and the order of rows within tables will be preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tables</td><td>a std::vector of Tables to be concatenated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>specify how to unify schema of input tables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memory_pool</td><td><a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> to be used if null-filled arrays need to be created or if existing column chunks need to endure type conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> </dd></dl>

</div>
</div>
<a id="ga1f99414177f1507f6efa3471cb650bbb" name="ga1f99414177f1507f6efa3471cb650bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f99414177f1507f6efa3471cb650bbb">&#9670;&#160;</a></span>Defaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structarrow_1_1ConcatenateTablesOptions.html">ConcatenateTablesOptions</a> arrow::ConcatenateTablesOptions::Defaults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gadc19bf0d1bcd8234e62d6dbce93e643b" name="gadc19bf0d1bcd8234e62d6dbce93e643b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc19bf0d1bcd8234e62d6dbce93e643b">&#9670;&#160;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::Table::Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1Table.html">Table</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_metadata</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if tables are equal. </p>
<p>Two tables can be equal only if they have equal schemas. However, they may be equal even if they have different chunkings. </p>

</div>
</div>
<a id="ga4222aea770ec19e0ce6769298c488619" name="ga4222aea770ec19e0ce6769298c488619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4222aea770ec19e0ce6769298c488619">&#9670;&#160;</a></span>field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Field.html">Field</a> &gt; arrow::Table::field </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column's field by index. </p>

</div>
</div>
<a id="ga90b9844bc25861874e7eefd7b513d7c1" name="ga90b9844bc25861874e7eefd7b513d7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90b9844bc25861874e7eefd7b513d7c1">&#9670;&#160;</a></span>fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Field.html">Field</a> &gt; &gt; arrow::Table::fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return vector of all fields for table. </p>

</div>
</div>
<a id="ga6fbb47dde07154f9940859028341d712" name="ga6fbb47dde07154f9940859028341d712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fbb47dde07154f9940859028341d712">&#9670;&#160;</a></span>Flatten()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::Flatten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flatten the table, producing a new <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a>. Any column with a struct type will be flattened into multiple columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The pool for buffer allocations, if any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8557289f578577b2d87aafbbfb96a005" name="ga8557289f578577b2d87aafbbfb96a005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8557289f578577b2d87aafbbfb96a005">&#9670;&#160;</a></span>FromChunkedStructArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::FromChunkedStructArray </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from a chunked <a class="el" href="classarrow_1_1StructArray.html" title="Concrete Array class for struct data.">StructArray</a>. One column will be produced for each field of the <a class="el" href="classarrow_1_1StructArray.html" title="Concrete Array class for struct data.">StructArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>a chunked <a class="el" href="classarrow_1_1StructArray.html" title="Concrete Array class for struct data.">StructArray</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa06cb917a909a30efd28aca46dd7ede3" name="gaa06cb917a909a30efd28aca46dd7ede3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa06cb917a909a30efd28aca46dd7ede3">&#9670;&#160;</a></span>FromRecordBatches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::FromRecordBatches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1RecordBatch.html">RecordBatch</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>batches</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from RecordBatches, using schema supplied by the first <a class="el" href="classarrow_1_1RecordBatch.html" title="Collection of equal-length arrays matching a particular Schema.">RecordBatch</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batches</td><td>a std::vector of record batches </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf783ad6e12e7c71507ce957c76717251" name="gaf783ad6e12e7c71507ce957c76717251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf783ad6e12e7c71507ce957c76717251">&#9670;&#160;</a></span>FromRecordBatches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::FromRecordBatches </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1RecordBatch.html">RecordBatch</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>batches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from RecordBatches, using supplied schema. There may be zero record batches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>the <a class="el" href="classarrow_1_1Schema.html" title="Sequence of arrow::Field objects describing the columns of a record batch or table data structure.">arrow::Schema</a> for each batch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batches</td><td>a std::vector of record batches </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e64d42ab6c95df2cd0f967a62ae2dc5" name="ga8e64d42ab6c95df2cd0f967a62ae2dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e64d42ab6c95df2cd0f967a62ae2dc5">&#9670;&#160;</a></span>FromRecordBatchReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::FromRecordBatchReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1RecordBatchReader.html">RecordBatchReader</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from a <a class="el" href="classarrow_1_1RecordBatchReader.html" title="Abstract interface for reading stream of record batches.">RecordBatchReader</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader</td><td>the <a class="el" href="classarrow_1_1RecordBatchReader.html" title="Abstract interface for reading stream of record batches.">arrow::RecordBatchReader</a> that produces batches </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac391f5d54cf24a7c57b592eb588b681b" name="gac391f5d54cf24a7c57b592eb588b681b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac391f5d54cf24a7c57b592eb588b681b">&#9670;&#160;</a></span>GetColumnByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt; arrow::Table::GetColumnByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>field name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classarrow_1_1Array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> or null if no field was found </dd></dl>

</div>
</div>
<a id="ga4a7b2c852c93db11d9b1fda4665a88c7" name="ga4a7b2c852c93db11d9b1fda4665a88c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a7b2c852c93db11d9b1fda4665a88c7">&#9670;&#160;</a></span>Make() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; arrow::Table::Make </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Array.html">Array</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num_rows</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from schema and arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>The table schema (column types) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrays</td><td>The table's columns as arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_rows</td><td>number of rows in table, -1 (default) to infer from columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab00e2717baa0a3984c094d84b46f3eb5" name="gab00e2717baa0a3984c094d84b46f3eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab00e2717baa0a3984c094d84b46f3eb5">&#9670;&#160;</a></span>Make() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; arrow::Table::Make </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num_rows</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> from schema and columns. </p>
<p>If columns is zero-length, the table's number of rows is zero</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>The table schema (column types) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columns</td><td>The table's columns as chunked arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_rows</td><td>number of rows in table, -1 (default) to infer from columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4ea65f8560c837132f8aac8a2f755f3" name="gad4ea65f8560c837132f8aac8a2f755f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4ea65f8560c837132f8aac8a2f755f3">&#9670;&#160;</a></span>MakeEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::MakeEmpty </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> of a given schema. </p>
<p>The output <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> will be created with a single empty chunk per column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>the schema of the empty <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>the memory pool to allocate memory from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> </dd></dl>

</div>
</div>
<a id="gabe71e003123973cdff9cfca40dc85e04" name="gabe71e003123973cdff9cfca40dc85e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe71e003123973cdff9cfca40dc85e04">&#9670;&#160;</a></span>num_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::Table::num_columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of columns in the table. </p>

</div>
</div>
<a id="ga14665d44a57c45343b54c7997d5c92e5" name="ga14665d44a57c45343b54c7997d5c92e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14665d44a57c45343b54c7997d5c92e5">&#9670;&#160;</a></span>num_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t arrow::Table::num_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of rows (equal to each column's logical length) </p>

</div>
</div>
<a id="ga1c477f7b61f120f856711407bbd6683b" name="ga1c477f7b61f120f856711407bbd6683b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c477f7b61f120f856711407bbd6683b">&#9670;&#160;</a></span>PromoteTableToSchema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::PromoteTableToSchema </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1compute_1_1CastOptions.html">compute::CastOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes a table to conform to the given schema. </p>
<p>If a field in the schema does not have a corresponding column in the table, a column of nulls will be added to the resulting table. If the corresponding column is of type Null, it will be promoted to the type specified by schema, with null values filled. The column will be casted to the type specified by the schema.</p>
<p>Returns an error:</p><ul>
<li>if the corresponding column's type is not compatible with the schema.</li>
<li>if there is a column in the table that does not exist in the schema.</li>
<li>if the cast fails or casting would be required but is not available.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the input <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>the target schema to promote to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The cast options to allow promotion of types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The memory pool to be used if null-filled arrays need to be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7b413e09909285c4bec08ac6e9a1fa0" name="gae7b413e09909285c4bec08ac6e9a1fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7b413e09909285c4bec08ac6e9a1fa0">&#9670;&#160;</a></span>PromoteTableToSchema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::PromoteTableToSchema </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1MemoryPool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="namespacearrow.html#a3fd0c21aaded24f07def6f62b34ac518">default_memory_pool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes a table to conform to the given schema. </p>
<p>If a field in the schema does not have a corresponding column in the table, a column of nulls will be added to the resulting table. If the corresponding column is of type Null, it will be promoted to the type specified by schema, with null values filled. The column will be casted to the type specified by the schema.</p>
<p>Returns an error:</p><ul>
<li>if the corresponding column's type is not compatible with the schema.</li>
<li>if there is a column in the table that does not exist in the schema.</li>
<li>if the cast fails or casting would be required but is not available.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the input <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>the target schema to promote to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The memory pool to be used if null-filled arrays need to be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31d001eabe7404ee8e3d7a568eae0e93" name="ga31d001eabe7404ee8e3d7a568eae0e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d001eabe7404ee8e3d7a568eae0e93">&#9670;&#160;</a></span>ReadNext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1Status.html">Status</a> arrow::TableBatchReader::ReadNext </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1RecordBatch.html">RecordBatch</a> &gt; *&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next record batch in the stream. Return null for batch when reaching end of stream. </p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">  std::shared_ptr&lt;RecordBatch&gt; batch;</div>
<div class="line">  <a class="code hl_define" href="status_8h.html#a4a98c16fff26a2c4cf8c26d9244c1cb4">ARROW_RETURN_NOT_OK</a>(reader-&gt;ReadNext(&amp;batch));</div>
<div class="line">  <span class="keywordflow">if</span> (!batch) {</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// handling the `batch`, the `batch-&gt;num_rows()`</span></div>
<div class="line">  <span class="comment">// might be 0.</span></div>
<div class="line">}</div>
<div class="ttc" id="astatus_8h_html_a4a98c16fff26a2c4cf8c26d9244c1cb4"><div class="ttname"><a href="status_8h.html#a4a98c16fff26a2c4cf8c26d9244c1cb4">ARROW_RETURN_NOT_OK</a></div><div class="ttdeci">#define ARROW_RETURN_NOT_OK(status)</div><div class="ttdoc">Propagate any non-successful Status to the caller.</div><div class="ttdef"><b>Definition</b> status.h:55</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">batch</td><td>the next loaded batch, null at end of stream. Returning an empty batch doesn't mean the end of stream because it is valid data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1Status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

<p>Implements <a class="el" href="classarrow_1_1RecordBatchReader.html#aaffe944df9d8a4c3e6592eb2f8f78f9f">arrow::RecordBatchReader</a>.</p>

</div>
</div>
<a id="ga6ec96eb75d66e8a6bfdc117331587aff" name="ga6ec96eb75d66e8a6bfdc117331587aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec96eb75d66e8a6bfdc117331587aff">&#9670;&#160;</a></span>RemoveColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::RemoveColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove column from the table, producing a new <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a>. </p>

</div>
</div>
<a id="ga786fe8fe5b6982e14c7956cb763e8729" name="ga786fe8fe5b6982e14c7956cb763e8729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga786fe8fe5b6982e14c7956cb763e8729">&#9670;&#160;</a></span>RenameColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::RenameColumns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename columns with provided names. </p>

</div>
</div>
<a id="gae8c4b17f00875e481b5df75aec60f54f" name="gae8c4b17f00875e481b5df75aec60f54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8c4b17f00875e481b5df75aec60f54f">&#9670;&#160;</a></span>ReplaceSchemaMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; arrow::Table::ReplaceSchemaMetadata </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classarrow_1_1KeyValueMetadata.html">KeyValueMetadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace schema key-value metadata with new metadata. </p>
<dl class="section since"><dt>Since</dt><dd>0.5.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata</td><td>new <a class="el" href="classarrow_1_1KeyValueMetadata.html" title="A container for key-value pair type metadata. Not thread-safe.">KeyValueMetadata</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a> </dd></dl>

</div>
</div>
<a id="ga0bbc06883035a8b88f8a88ee0d458cfe" name="ga0bbc06883035a8b88f8a88ee0d458cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bbc06883035a8b88f8a88ee0d458cfe">&#9670;&#160;</a></span>schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; &amp; arrow::Table::schema </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the table schema. </p>

</div>
</div>
<a id="ga0a97ebc32f740b0ec93b0bfe1ba73aa2" name="ga0a97ebc32f740b0ec93b0bfe1ba73aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a97ebc32f740b0ec93b0bfe1ba73aa2">&#9670;&#160;</a></span>schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Schema.html">Schema</a> &gt; arrow::TableBatchReader::schema </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the shared schema of the record batches in the stream </dd></dl>

<p>Implements <a class="el" href="classarrow_1_1RecordBatchReader.html#a5a3f5f0e1aff07743b0ef03bee6e4c49">arrow::RecordBatchReader</a>.</p>

</div>
</div>
<a id="ga9c009f45658bcef2bed8f68292057d0d" name="ga9c009f45658bcef2bed8f68292057d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c009f45658bcef2bed8f68292057d0d">&#9670;&#160;</a></span>SelectColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::SelectColumns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return new table with specified columns. </p>

</div>
</div>
<a id="ga293c77d9e315f264bc84e770d357b089" name="ga293c77d9e315f264bc84e770d357b089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293c77d9e315f264bc84e770d357b089">&#9670;&#160;</a></span>set_chunksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arrow::TableBatchReader::set_chunksize </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>chunksize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the desired maximum number of rows for record batches. </p>
<p>The actual number of rows in each record batch may be smaller, depending on actual chunking characteristics of each table column. </p>

</div>
</div>
<a id="ga3641d03292b554c9fce50fef40a5c2e1" name="ga3641d03292b554c9fce50fef40a5c2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3641d03292b554c9fce50fef40a5c2e1">&#9670;&#160;</a></span>SetColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; &gt; arrow::Table::SetColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Field.html">Field</a> &gt;&#160;</td>
          <td class="paramname"><em>field_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1ChunkedArray.html">ChunkedArray</a> &gt;&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a column in the table, producing a new <a class="el" href="classarrow_1_1Table.html" title="Logical table as sequence of chunked arrays.">Table</a>. </p>

</div>
</div>
<a id="gae9c432da346faaccb0ed8fccd4188d62" name="gae9c432da346faaccb0ed8fccd4188d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9c432da346faaccb0ed8fccd4188d62">&#9670;&#160;</a></span>Slice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; arrow::Table::Slice </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slice from first row at offset until end of the table. </p>

</div>
</div>
<a id="gaaa9d82d5fc1335373b5586816a698d75" name="gaaa9d82d5fc1335373b5586816a698d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa9d82d5fc1335373b5586816a698d75">&#9670;&#160;</a></span>Slice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt; arrow::Table::Slice </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a zero-copy slice of the table with the indicated offset and length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>the index of the first row in the constructed slice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the number of rows of the slice. If there are not enough rows in the table, the length will be adjusted accordingly</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new object wrapped in std::shared_ptr&lt;Table&gt; </dd></dl>

</div>
</div>
<a id="gaebd70d5a21ef0558472d6e594d3ceeb2" name="gaebd70d5a21ef0558472d6e594d3ceeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebd70d5a21ef0558472d6e594d3ceeb2">&#9670;&#160;</a></span>Table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::Table::Table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4ae1034b4c522d66da02ac1e17f30195" name="ga4ae1034b4c522d66da02ac1e17f30195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae1034b4c522d66da02ac1e17f30195">&#9670;&#160;</a></span>TableBatchReader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::TableBatchReader::TableBatchReader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1Table.html">Table</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1TableBatchReader.html" title="Compute a stream of record batches from a (possibly chunked) Table.">TableBatchReader</a> for the given table. </p>

</div>
</div>
<a id="ga0cfa28fb14217b6e9b82ea34e646b596" name="ga0cfa28fb14217b6e9b82ea34e646b596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cfa28fb14217b6e9b82ea34e646b596">&#9670;&#160;</a></span>TableBatchReader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::TableBatchReader::TableBatchReader </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1Table.html">Table</a> &gt;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga952001529c848c932349b3198d98b680" name="ga952001529c848c932349b3198d98b680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga952001529c848c932349b3198d98b680">&#9670;&#160;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string arrow::Table::ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>PrettyPrint representation suitable for debugging </dd></dl>

</div>
</div>
<a id="ga4a93ccc812c7ee9992bc9138b53895e0" name="ga4a93ccc812c7ee9992bc9138b53895e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a93ccc812c7ee9992bc9138b53895e0">&#9670;&#160;</a></span>Validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1Status.html">Status</a> arrow::Table::Validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform cheap validation checks to determine obvious inconsistencies within the table's schema and internal data. </p>
<p>This is O(k*m) where k is the total number of field descendents, and m is the number of chunks.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1Status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="ga5796527d5848794aff9b6b3107011dd7" name="ga5796527d5848794aff9b6b3107011dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5796527d5848794aff9b6b3107011dd7">&#9670;&#160;</a></span>ValidateFull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1Status.html">Status</a> arrow::Table::ValidateFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform extensive validation checks to determine inconsistencies within the table's schema and internal data. </p>
<p>This is O(k*n) where k is the total number of field descendents, and n is the number of rows.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1Status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="ga7ea1eed4818941b9b1eb98381e1b9690" name="ga7ea1eed4818941b9b1eb98381e1b9690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ea1eed4818941b9b1eb98381e1b9690">&#9670;&#160;</a></span>~Table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual arrow::Table::~Table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga20181bbcd6ae25ba49cadf11c636d4b3" name="ga20181bbcd6ae25ba49cadf11c636d4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20181bbcd6ae25ba49cadf11c636d4b3">&#9670;&#160;</a></span>field_merge_options</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarrow_1_1Field_1_1MergeOptions.html">Field::MergeOptions</a> arrow::ConcatenateTablesOptions::field_merge_options = <a class="el" href="structarrow_1_1Field_1_1MergeOptions.html#aad6ec10fe86793101bf688bbf9c9ad96">Field::MergeOptions::Defaults</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>options to control how fields are merged when unifying schemas</p>
<p>This field will be ignored if unify_schemas is false </p>

</div>
</div>
<a id="ga7b7b895c038e468dac1be8d27722ffa6" name="ga7b7b895c038e468dac1be8d27722ffa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b7b895c038e468dac1be8d27722ffa6">&#9670;&#160;</a></span>num_rows_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t arrow::Table::num_rows_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga40375f7767ae6caea748d87e53aacb45" name="ga40375f7767ae6caea748d87e53aacb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40375f7767ae6caea748d87e53aacb45">&#9670;&#160;</a></span>schema_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1Schema.html">Schema</a>&gt; arrow::Table::schema_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gac7c26f51a3023e3bc2eb6ae5a4510a9a" name="gac7c26f51a3023e3bc2eb6ae5a4510a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7c26f51a3023e3bc2eb6ae5a4510a9a">&#9670;&#160;</a></span>unify_schemas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::ConcatenateTablesOptions::unify_schemas = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, the schemas of the tables will be first unified with fields of the same name being merged, according to <code>field_merge_options</code>, then each table will be promoted to the unified schema before being concatenated. Otherwise, all tables should have the same schema. Each column in the output table is the result of concatenating the corresponding columns in all input tables. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
