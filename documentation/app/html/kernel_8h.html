<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Visualization of data from MMS: myenv/lib/python3.12/site-packages/pyarrow/include/arrow/compute/kernel.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Visualization of data from MMS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_f417cedcf73d481b49f4fd779a08a44f.html">myenv</a></li><li class="navelem"><a class="el" href="dir_3013c71e2f26f4ab12806518a35d2cf8.html">lib</a></li><li class="navelem"><a class="el" href="dir_9958de6440aed12841c226a051a061ea.html">python3.12</a></li><li class="navelem"><a class="el" href="dir_7b0cccbf4be0f8d911655a4b6cb1258d.html">site-packages</a></li><li class="navelem"><a class="el" href="dir_f0b0e6b6512054a9ff3c698b76f7e887.html">pyarrow</a></li><li class="navelem"><a class="el" href="dir_27b460b5602b2b78117a02c19a3bcb27.html">include</a></li><li class="navelem"><a class="el" href="dir_57a5a5af757defe47aa08dec7d9c94de.html">arrow</a></li><li class="navelem"><a class="el" href="dir_eb55dcb292fa31b90af00d83bd3df37c.html">compute</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">kernel.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="buffer_8h_source.html">arrow/buffer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="exec_8h_source.html">arrow/compute/exec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="datum_8h_source.html">arrow/datum.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="device__allocation__type__set_8h_source.html">arrow/device_allocation_type_set.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memory__pool_8h_source.html">arrow/memory_pool.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="result_8h_source.html">arrow/result.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="status_8h_source.html">arrow/status.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="type_8h_source.html">arrow/type.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">arrow/util/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="include_2arrow_2util_2visibility_8h_source.html">arrow/util/visibility.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for kernel.h:</div>
<div class="dyncontent">
<div class="center"><img src="kernel_8h__incl.png" border="0" usemap="#amyenv_2lib_2python3_812_2site-packages_2pyarrow_2include_2arrow_2compute_2kernel_8h" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="kernel_8h__dep__incl.png" border="0" usemap="#amyenv_2lib_2python3_812_2site-packages_2pyarrow_2include_2arrow_2compute_2kernel_8hdep" alt=""/></div>
<!-- MAP 1 -->
</div>
</div>
<p><a href="kernel_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1KernelState.html">arrow::compute::KernelState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for opaque kernel-specific state. For example, if there is some kind of initialization required.  <a href="structarrow_1_1compute_1_1KernelState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1KernelContext.html">arrow::compute::KernelContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context/state for the execution of a particular kernel.  <a href="classarrow_1_1compute_1_1KernelContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">arrow::compute::TypeMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An type-checking interface to permit customizable validation rules for use with <a class="el" href="classarrow_1_1compute_1_1InputType.html" title="An object used for type-checking arguments to be passed to a kernel and stored in a KernelSignature....">InputType</a> and <a class="el" href="classarrow_1_1compute_1_1KernelSignature.html" title="Holds the input types and output type of the kernel.">KernelSignature</a>. This is for scenarios where the acceptance is not an exact type instance, such as a TIMESTAMP type for a specific <a class="el" href="structarrow_1_1TimeUnit.html">TimeUnit</a>, but permitting any time zone.  <a href="structarrow_1_1compute_1_1TypeMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1InputType.html">arrow::compute::InputType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object used for type-checking arguments to be passed to a kernel and stored in a <a class="el" href="classarrow_1_1compute_1_1KernelSignature.html" title="Holds the input types and output type of the kernel.">KernelSignature</a>. The type-checking rule can be supplied either with an exact <a class="el" href="classarrow_1_1DataType.html" title="Base class for all data types.">DataType</a> instance or a custom <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html" title="An type-checking interface to permit customizable validation rules for use with InputType and KernelS...">TypeMatcher</a>.  <a href="classarrow_1_1compute_1_1InputType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1OutputType.html">arrow::compute::OutputType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container to capture both exact and input-dependent output types.  <a href="classarrow_1_1compute_1_1OutputType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1KernelSignature.html">arrow::compute::KernelSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the input types and output type of the kernel.  <a href="classarrow_1_1compute_1_1KernelSignature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1SimdLevel.html">arrow::compute::SimdLevel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function may contain multiple variants of a kernel for a given type combination for different SIMD levels. Based on the active system's CPU info or the user's preferences, we can elect to use one over the other.  <a href="structarrow_1_1compute_1_1SimdLevel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1NullHandling.html">arrow::compute::NullHandling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strategy to use for propagating or otherwise populating the validity bitmap of a kernel output.  <a href="structarrow_1_1compute_1_1NullHandling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1MemAllocation.html">arrow::compute::MemAllocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The preference for memory preallocation of fixed-width type outputs in kernel execution.  <a href="structarrow_1_1compute_1_1MemAllocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1KernelInitArgs.html">arrow::compute::KernelInitArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arguments to pass to an KernelInit function. A struct is used to help avoid API breakage should the arguments passed need to be expanded.  <a href="structarrow_1_1compute_1_1KernelInitArgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1Kernel.html">arrow::compute::Kernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for kernels. Contains the function signature and optionally the state initialization function, along with some common attributes.  <a href="structarrow_1_1compute_1_1Kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1ScalarKernel.html">arrow::compute::ScalarKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structarrow_1_1compute_1_1Kernel.html" title="Base type for kernels. Contains the function signature and optionally the state initialization functi...">Kernel</a> data structure for implementations of <a class="el" href="classarrow_1_1compute_1_1ScalarFunction.html" title="A function that executes elementwise operations on arrays or scalars, and therefore whose results gen...">ScalarFunction</a>. In addition to the members found in <a class="el" href="structarrow_1_1compute_1_1Kernel.html" title="Base type for kernels. Contains the function signature and optionally the state initialization functi...">Kernel</a>, contains the null handling and memory pre-allocation preferences.  <a href="structarrow_1_1compute_1_1ScalarKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1VectorKernel.html">arrow::compute::VectorKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structarrow_1_1compute_1_1Kernel.html" title="Base type for kernels. Contains the function signature and optionally the state initialization functi...">Kernel</a> data structure for implementations of <a class="el" href="classarrow_1_1compute_1_1VectorFunction.html" title="A function that executes general array operations that may yield outputs of different sizes or have r...">VectorFunction</a>. In contains an optional finalizer function, the null handling and memory pre-allocation preferences (which have different defaults from <a class="el" href="structarrow_1_1compute_1_1ScalarKernel.html" title="Kernel data structure for implementations of ScalarFunction. In addition to the members found in Kern...">ScalarKernel</a>), and some other execution-related options.  <a href="structarrow_1_1compute_1_1VectorKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1ScalarAggregateKernel.html">arrow::compute::ScalarAggregateKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structarrow_1_1compute_1_1Kernel.html" title="Base type for kernels. Contains the function signature and optionally the state initialization functi...">Kernel</a> data structure for implementations of <a class="el" href="classarrow_1_1compute_1_1ScalarAggregateFunction.html">ScalarAggregateFunction</a>. The four necessary components of an aggregation kernel are the init, consume, merge, and finalize functions.  <a href="structarrow_1_1compute_1_1ScalarAggregateKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1HashAggregateKernel.html">arrow::compute::HashAggregateKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structarrow_1_1compute_1_1Kernel.html" title="Base type for kernels. Contains the function signature and optionally the state initialization functi...">Kernel</a> data structure for implementations of <a class="el" href="classarrow_1_1compute_1_1HashAggregateFunction.html">HashAggregateFunction</a>. The four necessary components of an aggregation kernel are the init, consume, merge, and finalize functions.  <a href="structarrow_1_1compute_1_1HashAggregateKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacearrow" id="r_namespacearrow"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html">arrow</a></td></tr>
<tr class="memdesc:namespacearrow"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top-level namespace for Apache Arrow C++ API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1compute" id="r_namespacearrow_1_1compute"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html">arrow::compute</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1compute_1_1match" id="r_namespacearrow_1_1compute_1_1match"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html">arrow::compute::match</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7cc7abab771765f07269e89c17bc2742" id="r_a7cc7abab771765f07269e89c17bc2742"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a7cc7abab771765f07269e89c17bc2742">arrow::compute::KernelInit</a> = std::function&lt; <a class="el" href="classarrow_1_1Result.html">Result</a>&lt; std::unique_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1KernelState.html">KernelState</a> &gt; &gt;(<a class="el" href="classarrow_1_1compute_1_1KernelContext.html">KernelContext</a> *, const <a class="el" href="structarrow_1_1compute_1_1KernelInitArgs.html">KernelInitArgs</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a7cc7abab771765f07269e89c17bc2742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common initializer function for all kernel types.  <br /></td></tr>
<tr class="separator:a7cc7abab771765f07269e89c17bc2742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e74ba93c900377b3c7de9015c944add" id="r_a6e74ba93c900377b3c7de9015c944add"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a6e74ba93c900377b3c7de9015c944add">arrow::compute::ArrayKernelExec</a> = <a class="el" href="classarrow_1_1Status.html">Status</a>(*)(<a class="el" href="classarrow_1_1compute_1_1KernelContext.html">KernelContext</a> *, const <a class="el" href="structarrow_1_1compute_1_1ExecSpan.html">ExecSpan</a> &amp;, <a class="el" href="structarrow_1_1compute_1_1ExecResult.html">ExecResult</a> *)</td></tr>
<tr class="memdesc:a6e74ba93c900377b3c7de9015c944add"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar kernel execution API that must be implemented for SCALAR kernel types. This includes both stateless and stateful kernels. Kernels depending on some execution state access that state via subclasses of <a class="el" href="structarrow_1_1compute_1_1KernelState.html" title="Base class for opaque kernel-specific state. For example, if there is some kind of initialization req...">KernelState</a> set on the <a class="el" href="classarrow_1_1compute_1_1KernelContext.html" title="Context/state for the execution of a particular kernel.">KernelContext</a> object. Implementations should endeavor to write into pre-allocated memory if they are able, though for some kernels (e.g. in cases when a builder like <a class="el" href="classarrow_1_1StringBuilder.html" title="Builder class for UTF8 strings.">StringBuilder</a>) must be employed this may not be possible.  <br /></td></tr>
<tr class="separator:a6e74ba93c900377b3c7de9015c944add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83895d635d66d7d8a6d09d295c6fb1eb" id="r_a83895d635d66d7d8a6d09d295c6fb1eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a83895d635d66d7d8a6d09d295c6fb1eb">arrow::compute::ScalarAggregateConsume</a> = <a class="el" href="classarrow_1_1Status.html">Status</a>(*)(<a class="el" href="classarrow_1_1compute_1_1KernelContext.html">KernelContext</a> *, const <a class="el" href="structarrow_1_1compute_1_1ExecSpan.html">ExecSpan</a> &amp;)</td></tr>
<tr class="separator:a83895d635d66d7d8a6d09d295c6fb1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aef1d89c19bd1662640dd2c27e9f5f" id="r_ad7aef1d89c19bd1662640dd2c27e9f5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ad7aef1d89c19bd1662640dd2c27e9f5f">arrow::compute::ScalarAggregateMerge</a> = <a class="el" href="classarrow_1_1Status.html">Status</a>(*)(<a class="el" href="classarrow_1_1compute_1_1KernelContext.html">KernelContext</a> *, <a class="el" href="structarrow_1_1compute_1_1KernelState.html">KernelState</a> &amp;&amp;, <a class="el" href="structarrow_1_1compute_1_1KernelState.html">KernelState</a> *)</td></tr>
<tr class="separator:ad7aef1d89c19bd1662640dd2c27e9f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbea190ed26cb28c47e83ea8a5bc695" id="r_a3fbea190ed26cb28c47e83ea8a5bc695"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a3fbea190ed26cb28c47e83ea8a5bc695">arrow::compute::ScalarAggregateFinalize</a> = <a class="el" href="classarrow_1_1Status.html">Status</a>(*)(<a class="el" href="classarrow_1_1compute_1_1KernelContext.html">KernelContext</a> *, <a class="el" href="structarrow_1_1Datum.html">Datum</a> *)</td></tr>
<tr class="separator:a3fbea190ed26cb28c47e83ea8a5bc695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f78f4b4ea9391601735e7869ab88b3" id="r_a69f78f4b4ea9391601735e7869ab88b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a69f78f4b4ea9391601735e7869ab88b3">arrow::compute::HashAggregateResize</a> = <a class="el" href="classarrow_1_1Status.html">Status</a>(*)(<a class="el" href="classarrow_1_1compute_1_1KernelContext.html">KernelContext</a> *, int64_t)</td></tr>
<tr class="separator:a69f78f4b4ea9391601735e7869ab88b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bb0926fd613f38f85c3c5907202490" id="r_af5bb0926fd613f38f85c3c5907202490"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#af5bb0926fd613f38f85c3c5907202490">arrow::compute::HashAggregateConsume</a> = <a class="el" href="classarrow_1_1Status.html">Status</a>(*)(<a class="el" href="classarrow_1_1compute_1_1KernelContext.html">KernelContext</a> *, const <a class="el" href="structarrow_1_1compute_1_1ExecSpan.html">ExecSpan</a> &amp;)</td></tr>
<tr class="separator:af5bb0926fd613f38f85c3c5907202490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae824b7f36878d2279fa8c71c58ec0e9c" id="r_ae824b7f36878d2279fa8c71c58ec0e9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ae824b7f36878d2279fa8c71c58ec0e9c">arrow::compute::HashAggregateMerge</a> = <a class="el" href="classarrow_1_1Status.html">Status</a>(*)(<a class="el" href="classarrow_1_1compute_1_1KernelContext.html">KernelContext</a> *, <a class="el" href="structarrow_1_1compute_1_1KernelState.html">KernelState</a> &amp;&amp;, const <a class="el" href="structarrow_1_1ArrayData.html">ArrayData</a> &amp;)</td></tr>
<tr class="separator:ae824b7f36878d2279fa8c71c58ec0e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dd161f719aca7b43d03be06f92528a" id="r_af7dd161f719aca7b43d03be06f92528a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#af7dd161f719aca7b43d03be06f92528a">arrow::compute::HashAggregateFinalize</a> = <a class="el" href="classarrow_1_1Status.html">Status</a>(*)(<a class="el" href="classarrow_1_1compute_1_1KernelContext.html">KernelContext</a> *, <a class="el" href="structarrow_1_1Datum.html">Datum</a> *)</td></tr>
<tr class="separator:af7dd161f719aca7b43d03be06f92528a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a67c6503372c3a39c604acbf84dd4e13c" id="r_a67c6503372c3a39c604acbf84dd4e13c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#a67c6503372c3a39c604acbf84dd4e13c">arrow::compute::match::SameTypeId</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> type_id)</td></tr>
<tr class="memdesc:a67c6503372c3a39c604acbf84dd4e13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match any <a class="el" href="classarrow_1_1DataType.html" title="Base class for all data types.">DataType</a> instance having the same <a class="el" href="classarrow_1_1DataType.html#a5ec6a1c93420c68e9c8065d4a56ad645" title="Return the type category.">DataType::id</a>.  <br /></td></tr>
<tr class="separator:a67c6503372c3a39c604acbf84dd4e13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bfe9fa5f56760a87d340dde6839e49" id="r_ad3bfe9fa5f56760a87d340dde6839e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#ad3bfe9fa5f56760a87d340dde6839e49">arrow::compute::match::TimestampTypeUnit</a> (<a class="el" href="structarrow_1_1TimeUnit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a> unit)</td></tr>
<tr class="memdesc:ad3bfe9fa5f56760a87d340dde6839e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match any <a class="el" href="classarrow_1_1TimestampType.html" title="Concrete type class for datetime data (as number of seconds, milliseconds, microseconds or nanosecond...">TimestampType</a> instance having the same unit, but the time zones can be different.  <br /></td></tr>
<tr class="separator:ad3bfe9fa5f56760a87d340dde6839e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b215e37c66ca45d2994fea2997a2ad9" id="r_a8b215e37c66ca45d2994fea2997a2ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#a8b215e37c66ca45d2994fea2997a2ad9">arrow::compute::match::Time32TypeUnit</a> (<a class="el" href="structarrow_1_1TimeUnit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a> unit)</td></tr>
<tr class="separator:a8b215e37c66ca45d2994fea2997a2ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac184b03b6a1d66d149a434bd0f1a23a4" id="r_ac184b03b6a1d66d149a434bd0f1a23a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#ac184b03b6a1d66d149a434bd0f1a23a4">arrow::compute::match::Time64TypeUnit</a> (<a class="el" href="structarrow_1_1TimeUnit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a> unit)</td></tr>
<tr class="separator:ac184b03b6a1d66d149a434bd0f1a23a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1710e35c61dbeabb522a78bff3079118" id="r_a1710e35c61dbeabb522a78bff3079118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#a1710e35c61dbeabb522a78bff3079118">arrow::compute::match::DurationTypeUnit</a> (<a class="el" href="structarrow_1_1TimeUnit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a> unit)</td></tr>
<tr class="separator:a1710e35c61dbeabb522a78bff3079118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b5aa8dd98dd1a0c850189f589518b9" id="r_aa3b5aa8dd98dd1a0c850189f589518b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#aa3b5aa8dd98dd1a0c850189f589518b9">arrow::compute::match::Integer</a> ()</td></tr>
<tr class="separator:aa3b5aa8dd98dd1a0c850189f589518b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4191c9ab942c39a060626acbfa587de4" id="r_a4191c9ab942c39a060626acbfa587de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#a4191c9ab942c39a060626acbfa587de4">arrow::compute::match::BinaryLike</a> ()</td></tr>
<tr class="separator:a4191c9ab942c39a060626acbfa587de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2985292412f966bfb0bfae89759fc17e" id="r_a2985292412f966bfb0bfae89759fc17e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#a2985292412f966bfb0bfae89759fc17e">arrow::compute::match::LargeBinaryLike</a> ()</td></tr>
<tr class="separator:a2985292412f966bfb0bfae89759fc17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7393680e6c906e69ec1a0f99498bbb" id="r_a4e7393680e6c906e69ec1a0f99498bbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#a4e7393680e6c906e69ec1a0f99498bbb">arrow::compute::match::FixedSizeBinaryLike</a> ()</td></tr>
<tr class="separator:a4e7393680e6c906e69ec1a0f99498bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa722044f850514ca6bdbef884586d47d" id="r_aa722044f850514ca6bdbef884586d47d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#aa722044f850514ca6bdbef884586d47d">arrow::compute::match::Primitive</a> ()</td></tr>
<tr class="separator:aa722044f850514ca6bdbef884586d47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1c24350eb3258f8c9aa5fdd6f9789b" id="r_a8d1c24350eb3258f8c9aa5fdd6f9789b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#a8d1c24350eb3258f8c9aa5fdd6f9789b">arrow::compute::match::RunEndInteger</a> ()</td></tr>
<tr class="separator:a8d1c24350eb3258f8c9aa5fdd6f9789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d24ee2b8459353e30e61b5673f0ee5" id="r_a84d24ee2b8459353e30e61b5673f0ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#a84d24ee2b8459353e30e61b5673f0ee5">arrow::compute::match::RunEndEncoded</a> (std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt; value_type_matcher)</td></tr>
<tr class="memdesc:a84d24ee2b8459353e30e61b5673f0ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match run-end encoded types that use any valid run-end type and encode specific value types.  <br /></td></tr>
<tr class="separator:a84d24ee2b8459353e30e61b5673f0ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78fbfc0a676bc52a7bbe0398cb225e1" id="r_af78fbfc0a676bc52a7bbe0398cb225e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#af78fbfc0a676bc52a7bbe0398cb225e1">arrow::compute::match::RunEndEncoded</a> (<a class="el" href="structarrow_1_1Type.html#a00a041cb19a3be373da8eec7d4bf1f44">Type::type</a> value_type_id)</td></tr>
<tr class="memdesc:af78fbfc0a676bc52a7bbe0398cb225e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match run-end encoded types that use any valid run-end type and encode specific value types.  <br /></td></tr>
<tr class="separator:af78fbfc0a676bc52a7bbe0398cb225e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ddee338825d4743fb86e4bf995b298" id="r_a27ddee338825d4743fb86e4bf995b298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2arrow_2util_2visibility_8h.html#a7060b7b5f11fc11ce77a4d30b37619ef">ARROW_EXPORT</a> std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1match.html#a27ddee338825d4743fb86e4bf995b298">arrow::compute::match::RunEndEncoded</a> (std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt; run_end_type_matcher, std::shared_ptr&lt; <a class="el" href="structarrow_1_1compute_1_1TypeMatcher.html">TypeMatcher</a> &gt; value_type_matcher)</td></tr>
<tr class="memdesc:a27ddee338825d4743fb86e4bf995b298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match run-end encoded types that encode specific run-end and value types.  <br /></td></tr>
<tr class="separator:a27ddee338825d4743fb86e4bf995b298"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
