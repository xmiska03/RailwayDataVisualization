(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var Ji=Object.create;var Xe=Object.defineProperty;var qi=Object.getOwnPropertyDescriptor;var Qi=Object.getOwnPropertyNames;var en=Object.getPrototypeOf,tn=Object.prototype.hasOwnProperty;var Ye=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),on=(o,e)=>{for(var t in e)Xe(o,t,{get:e[t],enumerable:!0})},$e=(o,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Qi(e))!tn.call(o,n)&&n!==t&&Xe(o,n,{get:()=>e[n],enumerable:!(i=qi(e,n))||i.enumerable});return o},U=(o,e,t)=>($e(o,e,"default"),t&&$e(t,e,"default")),P=(o,e,t)=>(t=o!=null?Ji(en(o)):{},$e(e||!o||!o.__esModule?Xe(t,"default",{value:o,enumerable:!0}):t,o)),nn=o=>$e(Xe({},"__esModule",{value:!0}),o);var L=Ye(($r,Ut)=>{Ut.exports=globalThis.deck});var I=Ye((Yr,Bt)=>{Bt.exports=globalThis.luma});var ao=Ye((Sa,so)=>{so.exports=globalThis.loaders});var ti=Ye((Wl,Ft)=>{"use strict";Ft.exports=ct;Ft.exports.default=ct;function ct(o,e,t){t=t||2;var i=e&&e.length,n=i?e[0]*t:o.length,r=qo(o,0,n,t,!0),s=[];if(!r||r.next===r.prev)return s;var a,l,c,u,f,d,g;if(i&&(r=ur(o,e,r,t)),o.length>80*t){a=c=o[0],l=u=o[1];for(var p=t;p<n;p+=t)f=o[p],d=o[p+1],f<a&&(a=f),d<l&&(l=d),f>c&&(c=f),d>u&&(u=d);g=Math.max(c-a,u-l),g=g!==0?32767/g:0}return Ae(r,s,t,a,l,g,0),s}function qo(o,e,t,i,n){var r,s;if(n===Rt(o,e,t,i)>0)for(r=e;r<t;r+=i)s=Jo(r,o[r],o[r+1],s);else for(r=t-i;r>=e;r-=i)s=Jo(r,o[r],o[r+1],s);return s&&ut(s,s.next)&&(ze(s),s=s.next),s}function Y(o,e){if(!o)return o;e||(e=o);var t=o,i;do if(i=!1,!t.steiner&&(ut(t,t.next)||S(t.prev,t,t.next)===0)){if(ze(t),t=e=t.prev,t===t.next)break;i=!0}else t=t.next;while(i||t!==e);return e}function Ae(o,e,t,i,n,r,s){if(o){!s&&r&&hr(o,i,n,r);for(var a=o,l,c;o.prev!==o.next;){if(l=o.prev,c=o.next,r?ar(o,i,n,r):sr(o)){e.push(l.i/t|0),e.push(o.i/t|0),e.push(c.i/t|0),ze(o),o=c.next,a=c.next;continue}if(o=c,o===a){s?s===1?(o=lr(Y(o),e,t),Ae(o,e,t,i,n,r,2)):s===2&&cr(o,e,t,i,n,r):Ae(Y(o),e,t,i,n,r,1);break}}}}function sr(o){var e=o.prev,t=o,i=o.next;if(S(e,t,i)>=0)return!1;for(var n=e.x,r=t.x,s=i.x,a=e.y,l=t.y,c=i.y,u=n<r?n<s?n:s:r<s?r:s,f=a<l?a<c?a:c:l<c?l:c,d=n>r?n>s?n:s:r>s?r:s,g=a>l?a>c?a:c:l>c?l:c,p=i.next;p!==e;){if(p.x>=u&&p.x<=d&&p.y>=f&&p.y<=g&&ne(n,a,r,l,s,c,p.x,p.y)&&S(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function ar(o,e,t,i){var n=o.prev,r=o,s=o.next;if(S(n,r,s)>=0)return!1;for(var a=n.x,l=r.x,c=s.x,u=n.y,f=r.y,d=s.y,g=a<l?a<c?a:c:l<c?l:c,p=u<f?u<d?u:d:f<d?f:d,h=a>l?a>c?a:c:l>c?l:c,m=u>f?u>d?u:d:f>d?f:d,y=zt(g,p,e,t,i),_=zt(h,m,e,t,i),x=o.prevZ,v=o.nextZ;x&&x.z>=y&&v&&v.z<=_;){if(x.x>=g&&x.x<=h&&x.y>=p&&x.y<=m&&x!==n&&x!==s&&ne(a,u,l,f,c,d,x.x,x.y)&&S(x.prev,x,x.next)>=0||(x=x.prevZ,v.x>=g&&v.x<=h&&v.y>=p&&v.y<=m&&v!==n&&v!==s&&ne(a,u,l,f,c,d,v.x,v.y)&&S(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;x&&x.z>=y;){if(x.x>=g&&x.x<=h&&x.y>=p&&x.y<=m&&x!==n&&x!==s&&ne(a,u,l,f,c,d,x.x,x.y)&&S(x.prev,x,x.next)>=0)return!1;x=x.prevZ}for(;v&&v.z<=_;){if(v.x>=g&&v.x<=h&&v.y>=p&&v.y<=m&&v!==n&&v!==s&&ne(a,u,l,f,c,d,v.x,v.y)&&S(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function lr(o,e,t){var i=o;do{var n=i.prev,r=i.next.next;!ut(n,r)&&Qo(n,i,i.next,r)&&be(n,r)&&be(r,n)&&(e.push(n.i/t|0),e.push(i.i/t|0),e.push(r.i/t|0),ze(i),ze(i.next),i=o=r),i=i.next}while(i!==o);return Y(i)}function cr(o,e,t,i,n,r){var s=o;do{for(var a=s.next.next;a!==s.prev;){if(s.i!==a.i&&yr(s,a)){var l=ei(s,a);s=Y(s,s.next),l=Y(l,l.next),Ae(s,e,t,i,n,r,0),Ae(l,e,t,i,n,r,0);return}a=a.next}s=s.next}while(s!==o)}function ur(o,e,t,i){var n=[],r,s,a,l,c;for(r=0,s=e.length;r<s;r++)a=e[r]*i,l=r<s-1?e[r+1]*i:o.length,c=qo(o,a,l,i,!1),c===c.next&&(c.steiner=!0),n.push(xr(c));for(n.sort(fr),r=0;r<n.length;r++)t=dr(n[r],t);return t}function fr(o,e){return o.x-e.x}function dr(o,e){var t=gr(o,e);if(!t)return e;var i=ei(t,o);return Y(i,i.next),Y(t,t.next)}function gr(o,e){var t=e,i=o.x,n=o.y,r=-1/0,s;do{if(n<=t.y&&n>=t.next.y&&t.next.y!==t.y){var a=t.x+(n-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(a<=i&&a>r&&(r=a,s=t.x<t.next.x?t:t.next,a===i))return s}t=t.next}while(t!==e);if(!s)return null;var l=s,c=s.x,u=s.y,f=1/0,d;t=s;do i>=t.x&&t.x>=c&&i!==t.x&&ne(n<u?i:r,n,c,u,n<u?r:i,n,t.x,t.y)&&(d=Math.abs(n-t.y)/(i-t.x),be(t,o)&&(d<f||d===f&&(t.x>s.x||t.x===s.x&&pr(s,t)))&&(s=t,f=d)),t=t.next;while(t!==l);return s}function pr(o,e){return S(o.prev,o,e.prev)<0&&S(e.next,o,o.next)<0}function hr(o,e,t,i){var n=o;do n.z===0&&(n.z=zt(n.x,n.y,e,t,i)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next;while(n!==o);n.prevZ.nextZ=null,n.prevZ=null,mr(n)}function mr(o){var e,t,i,n,r,s,a,l,c=1;do{for(t=o,o=null,r=null,s=0;t;){for(s++,i=t,a=0,e=0;e<c&&(a++,i=i.nextZ,!!i);e++);for(l=c;a>0||l>0&&i;)a!==0&&(l===0||!i||t.z<=i.z)?(n=t,t=t.nextZ,a--):(n=i,i=i.nextZ,l--),r?r.nextZ=n:o=n,n.prevZ=r,r=n;t=i}r.nextZ=null,c*=2}while(s>1);return o}function zt(o,e,t,i,n){return o=(o-t)*n|0,e=(e-i)*n|0,o=(o|o<<8)&16711935,o=(o|o<<4)&252645135,o=(o|o<<2)&858993459,o=(o|o<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,o|e<<1}function xr(o){var e=o,t=o;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==o);return t}function ne(o,e,t,i,n,r,s,a){return(n-s)*(e-a)>=(o-s)*(r-a)&&(o-s)*(i-a)>=(t-s)*(e-a)&&(t-s)*(r-a)>=(n-s)*(i-a)}function yr(o,e){return o.next.i!==e.i&&o.prev.i!==e.i&&!vr(o,e)&&(be(o,e)&&be(e,o)&&Pr(o,e)&&(S(o.prev,o,e.prev)||S(o,e.prev,e))||ut(o,e)&&S(o.prev,o,o.next)>0&&S(e.prev,e,e.next)>0)}function S(o,e,t){return(e.y-o.y)*(t.x-e.x)-(e.x-o.x)*(t.y-e.y)}function ut(o,e){return o.x===e.x&&o.y===e.y}function Qo(o,e,t,i){var n=lt(S(o,e,t)),r=lt(S(o,e,i)),s=lt(S(t,i,o)),a=lt(S(t,i,e));return!!(n!==r&&s!==a||n===0&&at(o,t,e)||r===0&&at(o,i,e)||s===0&&at(t,o,i)||a===0&&at(t,e,i))}function at(o,e,t){return e.x<=Math.max(o.x,t.x)&&e.x>=Math.min(o.x,t.x)&&e.y<=Math.max(o.y,t.y)&&e.y>=Math.min(o.y,t.y)}function lt(o){return o>0?1:o<0?-1:0}function vr(o,e){var t=o;do{if(t.i!==o.i&&t.next.i!==o.i&&t.i!==e.i&&t.next.i!==e.i&&Qo(t,t.next,o,e))return!0;t=t.next}while(t!==o);return!1}function be(o,e){return S(o.prev,o,o.next)<0?S(o,e,o.next)>=0&&S(o,o.prev,e)>=0:S(o,e,o.prev)<0||S(o,o.next,e)<0}function Pr(o,e){var t=o,i=!1,n=(o.x+e.x)/2,r=(o.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&n<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(i=!i),t=t.next;while(t!==o);return i}function ei(o,e){var t=new Ot(o.i,o.x,o.y),i=new Ot(e.i,e.x,e.y),n=o.next,r=e.prev;return o.next=e,e.prev=o,t.next=n,n.prev=t,i.next=t,t.prev=i,r.next=i,i.prev=r,i}function Jo(o,e,t,i){var n=new Ot(o,e,t);return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function ze(o){o.next.prev=o.prev,o.prev.next=o.next,o.prevZ&&(o.prevZ.nextZ=o.nextZ),o.nextZ&&(o.nextZ.prevZ=o.prevZ)}function Ot(o,e,t){this.i=o,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}ct.deviation=function(o,e,t,i){var n=e&&e.length,r=n?e[0]*t:o.length,s=Math.abs(Rt(o,0,r,t));if(n)for(var a=0,l=e.length;a<l;a++){var c=e[a]*t,u=a<l-1?e[a+1]*t:o.length;s-=Math.abs(Rt(o,c,u,t))}var f=0;for(a=0;a<i.length;a+=3){var d=i[a]*t,g=i[a+1]*t,p=i[a+2]*t;f+=Math.abs((o[d]-o[p])*(o[g+1]-o[d+1])-(o[d]-o[g])*(o[p+1]-o[d+1]))}return s===0&&f===0?0:Math.abs((f-s)/s)};function Rt(o,e,t,i){for(var n=0,r=e,s=t-i;r<t;r+=i)n+=(o[s]-o[r])*(o[r+1]+o[s+1]),s=r;return n}ct.flatten=function(o){for(var e=o[0][0].length,t={vertices:[],holes:[],dimensions:e},i=0,n=0;n<o.length;n++){for(var r=0;r<o[n].length;r++)for(var s=0;s<e;s++)t.vertices.push(o[n][r][s]);n>0&&(i+=o[n-1].length,t.holes.push(i))}return t}});var Ze={};on(Ze,{ArcLayer:()=>Kt,BitmapLayer:()=>io,ColumnLayer:()=>st,GeoJsonLayer:()=>$i,GridCellLayer:()=>Bo,IconLayer:()=>te,LineLayer:()=>vo,PathLayer:()=>ie,PointCloudLayer:()=>So,PolygonLayer:()=>hi,ScatterplotLayer:()=>tt,SolidPolygonLayer:()=>se,TextLayer:()=>Pt,_MultiIconLayer:()=>xt,_TextBackgroundLayer:()=>vt});var R={},Gt=P(L(),1);U(R,P(L(),1));if(!Gt.Layer)throw new Error("@deck.gl/core is not found");U(Ze,R);var G=P(L(),1),Zt=P(I(),1),Ht=P(I(),1);var jt=`#version 300 es
#define SHADER_NAME arc-layer-vertex-shader
in vec3 positions;
in vec4 instanceSourceColors;
in vec4 instanceTargetColors;
in vec3 instanceSourcePositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions;
in vec3 instanceTargetPositions64Low;
in vec3 instancePickingColors;
in float instanceWidths;
in float instanceHeights;
in float instanceTilts;
uniform bool greatCircle;
uniform bool useShortestPath;
uniform float numSegments;
uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int widthUnits;
out vec4 vColor;
out vec2 uv;
out float isValid;
float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
float deltaZ = targetZ - sourceZ;
float dh = distance * instanceHeights;
if (dh == 0.0) {
return sourceZ + deltaZ * ratio;
}
float unitZ = deltaZ / dh;
float p2 = unitZ * unitZ + 1.0;
float dir = step(deltaZ, 0.0);
float z0 = mix(sourceZ, targetZ, dir);
float r = mix(ratio, 1.0 - ratio, dir);
return sqrt(r * (p2 - r)) * dh + z0;
}
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
float getSegmentRatio(float index) {
return smoothstep(0.0, 1.0, index / (numSegments - 1.0));
}
vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
float distance = length(source.xy - target.xy);
float z = paraboloid(distance, source.z, target.z, segmentRatio);
float tiltAngle = radians(instanceTilts);
vec2 tiltDirection = normalize(target.xy - source.xy);
vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);
return vec3(
mix(source.xy, target.xy, segmentRatio) + tilt,
z * cos(tiltAngle)
);
}
float getAngularDist (vec2 source, vec2 target) {
vec2 sourceRadians = radians(source);
vec2 targetRadians = radians(target);
vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
vec2 shd_sq = sin_half_delta * sin_half_delta;
float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
return 2.0 * asin(sqrt(a));
}
vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
vec2 lngLat;
if(abs(angularDist - PI) < 0.001) {
lngLat = (1.0 - t) * source.xy + t * target.xy;
} else {
float a = sin((1.0 - t) * angularDist);
float b = sin(t * angularDist);
vec3 p = source3D.yxz * a + target3D.yxz * b;
lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
}
float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);
return vec3(lngLat, z);
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
float segmentIndex = positions.x;
float segmentRatio = getSegmentRatio(segmentIndex);
float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));
float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
isValid = 1.0;
uv = vec2(segmentRatio, positions.y);
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
vec4 curr;
vec4 next;
vec3 source;
vec3 target;
if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);
vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);
if (abs(currPos.x - prevPos.x) > 180.0) {
indexDir = -1.0;
isValid = 0.0;
} else if (abs(currPos.x - nextPos.x) > 180.0) {
indexDir = 1.0;
isValid = 0.0;
}
nextPos = indexDir < 0.0 ? prevPos : nextPos;
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
if (isValid == 0.0) {
nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
currPos = mix(currPos, nextPos, t);
segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
}
vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
} else {
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
if (useShortestPath) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng > 180.) target_world.x -= 360.;
if (deltaLng < -180.) source_world.x -= 360.;
}
source = project_position(source_world, instanceSourcePositions64Low);
target = project_position(target_world, instanceTargetPositions64Low);
float antiMeridianX = 0.0;
if (useShortestPath) {
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;
}
float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);
if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
isValid = 0.0;
indexDir = sign(segmentRatio - thresholdRatio);
segmentRatio = thresholdRatio;
}
}
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
vec3 currPos = interpolateFlat(source, target, segmentRatio);
vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);
if (useShortestPath) {
if (nextPos.x < antiMeridianX) {
currPos.x += TILE_SIZE;
nextPos.x += TILE_SIZE;
}
}
curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
geometry.position = vec4(currPos, 1.0);
}
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(curr, geometry);
gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
vColor = vec4(color.rgb, color.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var Vt=`#version 300 es
#define SHADER_NAME arc-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
in float isValid;
out vec4 fragColor;
void main(void) {
if (isValid == 0.0) {
discard;
}
fragColor = vColor;
geometry.uv = uv;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Je=[0,0,0,255],rn={getSourcePosition:{type:"accessor",value:o=>o.sourcePosition},getTargetPosition:{type:"accessor",value:o=>o.targetPosition},getSourceColor:{type:"accessor",value:Je},getTargetColor:{type:"accessor",value:Je},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,numSegments:{type:"number",value:50,min:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}},de=class extends G.Layer{getBounds(){return this.getAttributeManager()?.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:jt,fs:Vt,modules:[G.project32,G.picking]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getSourceColor",defaultValue:Je},instanceTargetColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getTargetColor",defaultValue:Je},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(e){super.updateState(e);let{props:t,oldProps:i,changeFlags:n}=e;(n.extensionsChanged||t.numSegments!==i.numSegments)&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:e}){let{widthUnits:t,widthScale:i,widthMinPixels:n,widthMaxPixels:r,greatCircle:s,wrapLongitude:a}=this.props,l=this.state.model;l.setUniforms(e),l.setUniforms({greatCircle:s,widthUnits:G.UNIT[t],widthScale:i,widthMinPixels:n,widthMaxPixels:r,useShortestPath:a}),l.draw(this.context.renderPass)}_getModel(){let{numSegments:e}=this.props,t=[];for(let n=0;n<e;n++)t=t.concat([n,1,0,n,-1,0]);let i=new Ht.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new Zt.Geometry({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array(t)}}}),isInstanced:!0});return i.setUniforms({numSegments:e}),i}};de.layerName="ArcLayer";de.defaultProps=rn;var Kt=de;var k=P(L(),1),oo=P(I(),1);var os=1/Math.PI*180,is=1/180*Math.PI,sn={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0,_cartographicRadians:!1};globalThis.mathgl=globalThis.mathgl||{config:{...sn}};var an=globalThis.mathgl.config;function $t(o){return Array.isArray(o)||ArrayBuffer.isView(o)&&!(o instanceof DataView)}function ee(o,e,t){return $t(o)?o.map((i,n)=>ee(i,e[n],t)):t*e+(1-t)*o}function qe(o,e){if(!o)throw new Error(e||"@math.gl/web-mercator: assertion failed.")}var K=Math.PI,fn=K/4,Xt=K/180,Is=180/K,Yt=512;function $(o){let[e,t]=o;qe(Number.isFinite(e)),qe(Number.isFinite(t)&&t>=-90&&t<=90,"invalid latitude");let i=e*Xt,n=t*Xt,r=Yt*(i+K)/(2*K),s=Yt*(K+Math.log(Math.tan(fn+n*.5)))/(2*K);return[r,s]}var Ds=Math.PI/180;var Sn=new Uint32Array([0,2,1,0,3,2]),wn=new Float32Array([0,1,0,0,1,0,1,1]);function wt(o,e){if(!e)return Mn(o);let t=Math.max(Math.abs(o[0][0]-o[3][0]),Math.abs(o[1][0]-o[2][0])),i=Math.max(Math.abs(o[1][1]-o[0][1]),Math.abs(o[2][1]-o[3][1])),n=Math.ceil(t/e)+1,r=Math.ceil(i/e)+1,s=(n-1)*(r-1)*6,a=new Uint32Array(s),l=new Float32Array(n*r*2),c=new Float64Array(n*r*3),u=0,f=0;for(let d=0;d<n;d++){let g=d/(n-1);for(let p=0;p<r;p++){let h=p/(r-1),m=Tn(o,g,h);c[u*3+0]=m[0],c[u*3+1]=m[1],c[u*3+2]=m[2]||0,l[u*2+0]=g,l[u*2+1]=1-h,d>0&&p>0&&(a[f++]=u-r,a[f++]=u-r-1,a[f++]=u-1,a[f++]=u-r,a[f++]=u-1,a[f++]=u),u++}}return{vertexCount:s,positions:c,indices:a,texCoords:l}}function Mn(o){let e=new Float64Array(12);for(let t=0;t<o.length;t++)e[t*3+0]=o[t][0],e[t*3+1]=o[t][1],e[t*3+2]=o[t][2]||0;return{vertexCount:6,positions:e,indices:Sn,texCoords:wn}}function Tn(o,e,t){return ee(ee(o[0],o[1],t),ee(o[3],o[2],t),e)}var Qt=`#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

uniform float coordinateConversion;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;
  } else if (coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;var In=`
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`,eo=`#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

uniform float desaturate;
uniform vec4 transparentColor;
uniform vec3 tintColor;
uniform float opacity;

uniform float coordinateConversion;
uniform vec4 bounds;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),
    (pos.y - bounds[3]) / (bounds[1] - bounds[3])
  );
}

${In}

void main(void) {
  vec2 uv = vTexCoord;
  if (coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;var En={image:{type:"image",value:null,async:!0},bounds:{type:"array",value:[1,0,0,1],compare:!0},_imageCoordinateSystem:k.COORDINATE_SYSTEM.DEFAULT,desaturate:{type:"number",min:0,max:1,value:0},transparentColor:{type:"color",value:[0,0,0,0]},tintColor:{type:"color",value:[255,255,255]},textureParameters:{type:"object",ignore:!0,value:null}},pe=class extends k.Layer{getShaders(){return super.getShaders({vs:Qt,fs:eo,modules:[k.project32,k.picking]})}initializeState(){let e=this.getAttributeManager();e.remove(["instancePickingColors"]);let t=!0;e.add({indices:{size:1,isIndexed:!0,update:i=>i.value=this.state.mesh.indices,noAlloc:t},positions:{size:3,type:"float64",fp64:this.use64bitPositions(),update:i=>i.value=this.state.mesh.positions,noAlloc:t},texCoords:{size:2,update:i=>i.value=this.state.mesh.texCoords,noAlloc:t}})}updateState({props:e,oldProps:t,changeFlags:i}){let n=this.getAttributeManager();if(i.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),n.invalidateAll()),e.bounds!==t.bounds){let r=this.state.mesh,s=this._createMesh();this.state.model.setVertexCount(s.vertexCount);for(let a in s)r&&r[a]!==s[a]&&n.invalidate(a);this.setState({mesh:s,...this._getCoordinateUniforms()})}else e._imageCoordinateSystem!==t._imageCoordinateSystem&&this.setState(this._getCoordinateUniforms())}getPickingInfo(e){let{image:t}=this.props,i=e.info;if(!i.color||!t)return i.bitmap=null,i;let{width:n,height:r}=t;i.index=0;let s=An(i.color);return i.bitmap={size:{width:n,height:r},uv:s,pixel:[Math.floor(s[0]*n),Math.floor(s[1]*r)]},i}disablePickingIndex(){this.setState({disablePicking:!0})}restorePickingColors(){this.setState({disablePicking:!1})}_updateAutoHighlight(e){super._updateAutoHighlight({...e,color:this.encodePickingColor(0)})}_createMesh(){let{bounds:e}=this.props,t=e;return to(e)&&(t=[[e[0],e[1]],[e[0],e[3]],[e[2],e[3]],[e[2],e[1]]]),wt(t,this.context.viewport.resolution)}_getModel(){return new oo.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),topology:"triangle-list",isInstanced:!1})}draw(e){let{uniforms:t,moduleParameters:i}=e,{model:n,coordinateConversion:r,bounds:s,disablePicking:a}=this.state,{image:l,desaturate:c,transparentColor:u,tintColor:f}=this.props;i.picking.isActive&&a||l&&n&&(n.setUniforms(t),n.setBindings({bitmapTexture:l}),n.setUniforms({desaturate:c,transparentColor:u.map(d=>d/255),tintColor:f.slice(0,3).map(d=>d/255),coordinateConversion:r,bounds:s}),n.draw(this.context.renderPass))}_getCoordinateUniforms(){let{LNGLAT:e,CARTESIAN:t,DEFAULT:i}=k.COORDINATE_SYSTEM,{_imageCoordinateSystem:n}=this.props;if(n!==i){let{bounds:r}=this.props;if(!to(r))throw new Error("_imageCoordinateSystem only supports rectangular bounds");let s=this.context.viewport.resolution?e:t;if(n=n===e?e:t,n===e&&s===t)return{coordinateConversion:-1,bounds:r};if(n===t&&s===e){let a=$([r[0],r[1]]),l=$([r[2],r[3]]);return{coordinateConversion:1,bounds:[a[0],a[1],l[0],l[1]]}}}return{coordinateConversion:0,bounds:[0,0,0,0]}}};pe.layerName="BitmapLayer";pe.defaultProps=En;var io=pe;function An(o){let[e,t,i]=o,n=(i&240)/256,r=(i&15)/16;return[(e+r)/256,(t+n)/256]}function to(o){return Number.isFinite(o[0])}var F=P(L(),1),Qe=P(I(),1);var no=`#version 300 es
#define SHADER_NAME icon-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;
uniform float sizeScale;
uniform vec2 iconsTextureDim;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform bool billboard;
uniform int sizeUnits;
out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = angle * PI / 180.0;
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vec2 iconSize = instanceIconFrames.zw;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),
sizeMinPixels, sizeMaxPixels
);
float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;
vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
pixelOffset += instancePixelOffset;
pixelOffset.y *= -1.0;
if (billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vTextureCoords = mix(
instanceIconFrames.xy,
instanceIconFrames.xy + iconSize,
(positions.xy + 1.0) / 2.0
) / iconsTextureDim;
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
vColorMode = instanceColorModes;
}
`;var ro=`#version 300 es
#define SHADER_NAME icon-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D iconsTexture;
uniform float alphaCutoff;
in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec4 texColor = texture(iconsTexture, vTextureCoords);
vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
float a = texColor.a * opacity * vColor.a;
if (a < alphaCutoff) {
discard;
}
fragColor = vec4(color, a);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var fo=P(ao(),1),go=P(L(),1),bn=1024,zn=4,lo=()=>{},co={minFilter:"linear",mipmapFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},On={x:0,y:0,width:0,height:0};function Rn(o){return Math.pow(2,Math.ceil(Math.log2(o)))}function Fn(o,e,t,i){let n=Math.min(t/e.width,i/e.height),r=Math.floor(e.width*n),s=Math.floor(e.height*n);return n===1?{data:e,width:r,height:s}:(o.canvas.height=s,o.canvas.width=r,o.clearRect(0,0,r,s),o.drawImage(e,0,0,e.width,e.height,0,0,r,s),{data:o.canvas,width:r,height:s})}function he(o){return o&&(o.id||o.url)}function Dn(o,e,t,i){let{width:n,height:r,device:s}=o,a=s.createTexture({format:"rgba8unorm",width:e,height:t,sampler:i}),l=s.createCommandEncoder();return l.copyTextureToTexture({source:o,destination:a,width:n,height:r}),l.finish(),o.destroy(),a}function uo(o,e,t){for(let i=0;i<e.length;i++){let{icon:n,xOffset:r}=e[i],s=he(n);o[s]={...n,x:r,y:t}}}function Nn({icons:o,buffer:e,mapping:t={},xOffset:i=0,yOffset:n=0,rowHeight:r=0,canvasWidth:s}){let a=[];for(let l=0;l<o.length;l++){let c=o[l],u=he(c);if(!t[u]){let{height:f,width:d}=c;i+d+e>s&&(uo(t,a,n),i=0,n=r+n+e,r=0,a=[]),a.push({icon:c,xOffset:i}),i=i+d+e,r=Math.max(r,f)}}return a.length>0&&uo(t,a,n),{mapping:t,rowHeight:r,xOffset:i,yOffset:n,canvasWidth:s,canvasHeight:Rn(r+n+e)}}function kn(o,e,t){if(!o||!e)return null;t=t||{};let i={},{iterable:n,objectInfo:r}=(0,go.createIterable)(o);for(let s of n){r.index++;let a=e(s,r),l=he(a);if(!a)throw new Error("Icon is missing.");if(!a.url)throw new Error("Icon url is missing.");!i[l]&&(!t[l]||a.url!==t[l].url)&&(i[l]={...a,source:s,sourceIndex:r.index})}return i}var me=class{constructor(e,{onUpdate:t=lo,onError:i=lo}){this._loadOptions=null,this._texture=null,this._externalTexture=null,this._mapping={},this._textureParameters=null,this._pendingCount=0,this._autoPacking=!1,this._xOffset=0,this._yOffset=0,this._rowHeight=0,this._buffer=zn,this._canvasWidth=bn,this._canvasHeight=0,this._canvas=null,this.device=e,this.onUpdate=t,this.onError=i}finalize(){this._texture?.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(e){let t=this._autoPacking?he(e):e;return this._mapping[t]||On}setProps({loadOptions:e,autoPacking:t,iconAtlas:i,iconMapping:n,textureParameters:r}){e&&(this._loadOptions=e),t!==void 0&&(this._autoPacking=t),n&&(this._mapping=n),i&&(this._texture?.delete(),this._texture=null,this._externalTexture=i),r&&(this._textureParameters=r)}get isLoaded(){return this._pendingCount===0}packIcons(e,t){if(!this._autoPacking||typeof document>"u")return;let i=Object.values(kn(e,t,this._mapping)||{});if(i.length>0){let{mapping:n,xOffset:r,yOffset:s,rowHeight:a,canvasHeight:l}=Nn({icons:i,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=a,this._mapping=n,this._xOffset=r,this._yOffset=s,this._canvasHeight=l,this._texture||(this._texture=this.device.createTexture({format:"rgba8unorm",width:this._canvasWidth,height:this._canvasHeight,sampler:this._textureParameters||co})),this._texture.height!==this._canvasHeight&&(this._texture=Dn(this._texture,this._canvasWidth,this._canvasHeight,this._textureParameters||co)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(i)}}_loadIcons(e){let t=this._canvas.getContext("2d",{willReadFrequently:!0});for(let i of e)this._pendingCount++,(0,fo.load)(i.url,this._loadOptions).then(n=>{let r=he(i),s=this._mapping[r],{x:a,y:l,width:c,height:u}=s,{data:f,width:d,height:g}=Fn(t,n,c,u);this._texture.setSubImageData({data:f,x:a+(c-d)/2,y:l+(u-g)/2,width:d,height:g}),s.width=d,s.height=g,this._texture.generateMipmap(),this.onUpdate()}).catch(n=>{this.onError({url:i.url,source:i.source,sourceIndex:i.sourceIndex,loadOptions:this._loadOptions,error:n})}).finally(()=>{this._pendingCount--})}};var po=[0,0,0,255],Wn={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:o=>o.position},getIcon:{type:"accessor",value:o=>o.icon},getColor:{type:"accessor",value:po},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,optional:!0},textureParameters:{type:"object",ignore:!0,value:null}},xe=class extends F.Layer{getShaders(){return super.getShaders({vs:no,fs:ro,modules:[F.project32,F.picking]})}initializeState(){this.state={iconManager:new me(this.context.device,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})},this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:"uint8",accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:po},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(e){super.updateState(e);let{props:t,oldProps:i,changeFlags:n}=e,r=this.getAttributeManager(),{iconAtlas:s,iconMapping:a,data:l,getIcon:c,textureParameters:u}=t,{iconManager:f}=this.state;if(typeof s=="string")return;let d=s||this.internalState.isAsyncPropLoading("iconAtlas");f.setProps({loadOptions:t.loadOptions,autoPacking:!d,iconAtlas:s,iconMapping:d?a:null,textureParameters:u}),d?i.iconMapping!==t.iconMapping&&r.invalidate("getIcon"):(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getIcon))&&f.packIcons(l,c),n.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),r.invalidateAll())}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(e){super.finalizeState(e),this.state.iconManager.finalize()}draw({uniforms:e}){let{sizeScale:t,sizeMinPixels:i,sizeMaxPixels:n,sizeUnits:r,billboard:s,alphaCutoff:a}=this.props,{iconManager:l}=this.state,c=l.getTexture();if(c){let u=this.state.model;u.setBindings({iconsTexture:c}),u.setUniforms(e),u.setUniforms({iconsTextureDim:[c.width,c.height],sizeUnits:F.UNIT[r],sizeScale:t,sizeMinPixels:i,sizeMaxPixels:n,billboard:s,alphaCutoff:a}),u.draw(this.context.renderPass)}}_getModel(){let e=[-1,-1,1,-1,-1,1,1,1];return new Qe.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new Qe.Geometry({topology:"triangle-strip",attributes:{positions:{size:2,value:new Float32Array(e)}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(e){let t=this.getCurrentLayer()?.props.onIconError;t?t(e):F.log.error(e.error.message)()}getInstanceOffset(e){let{width:t,height:i,anchorX:n=t/2,anchorY:r=i/2}=this.state.iconManager.getIconMapping(e);return[t/2-n,i/2-r]}getInstanceColorMode(e){return this.state.iconManager.getIconMapping(e).mask?1:0}getInstanceIconFrame(e){let{x:t,y:i,width:n,height:r}=this.state.iconManager.getIconMapping(e);return[t,i,n,r]}};xe.defaultProps=Wn;xe.layerName="IconLayer";var te=xe;var B=P(L(),1),xo=P(I(),1),yo=P(I(),1);var ho=`#version 300 es
#define SHADER_NAME line-layer-vertex-shader
in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;
uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float useShortestPath;
uniform int widthUnits;
out vec4 vColor;
out vec2 uv;
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
vec3 splitLine(vec3 a, vec3 b, float x) {
float t = (x - a.x) / (b.x - a.x);
return vec3(x, mix(a.yz, b.yz, t));
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
vec3 source_world_64low = instanceSourcePositions64Low;
vec3 target_world_64low = instanceTargetPositions64Low;
if (useShortestPath > 0.5 || useShortestPath < -0.5) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng * useShortestPath > 180.) {
source_world.x += 360. * useShortestPath;
source_world = splitLine(source_world, target_world, 180. * useShortestPath);
source_world_64low = vec3(0.0);
} else if (deltaLng * useShortestPath < -180.) {
target_world.x += 360. * useShortestPath;
target_world = splitLine(source_world, target_world, 180. * useShortestPath);
target_world_64low = vec3(0.0);
} else if (useShortestPath < 0.) {
gl_Position = vec4(0.);
return;
}
}
vec4 source_commonspace;
vec4 target_commonspace;
vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
float segmentIndex = positions.x;
vec4 p = mix(source, target, segmentIndex);
geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
uv = positions.xy;
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(p, geometry);
gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var mo=`#version 300 es
#define SHADER_NAME line-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Un=[0,0,0,255],Gn={getSourcePosition:{type:"accessor",value:o=>o.sourcePosition},getTargetPosition:{type:"accessor",value:o=>o.targetPosition},getColor:{type:"accessor",value:Un},getWidth:{type:"accessor",value:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}},ye=class extends B.Layer{getBounds(){return this.getAttributeManager()?.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:ho,fs:mo,modules:[B.project32,B.picking]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:[0,0,0,255]},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1}})}updateState(e){super.updateState(e),e.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:e}){let{widthUnits:t,widthScale:i,widthMinPixels:n,widthMaxPixels:r,wrapLongitude:s}=this.props,a=this.state.model;a.setUniforms(e),a.setUniforms({widthUnits:B.UNIT[t],widthScale:i,widthMinPixels:n,widthMaxPixels:r,useShortestPath:s?1:0}),a.draw(this.context.renderPass),s&&(a.setUniforms({useShortestPath:-1}),a.draw(this.context.renderPass))}_getModel(){let e=[0,-1,0,0,1,0,1,-1,0,1,1,0];return new yo.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new xo.Geometry({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array(e)}}}),isInstanced:!0})}};ye.layerName="LineLayer";ye.defaultProps=Gn;var vo=ye;var D=P(L(),1),et=P(I(),1);var Po=`#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var _o=`#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Co=[0,0,0,255],Lo=[0,0,1],Bn={sizeUnits:"pixels",pointSize:{type:"number",min:0,value:10},getPosition:{type:"accessor",value:o=>o.position},getNormal:{type:"accessor",value:Lo},getColor:{type:"accessor",value:Co},material:!0,radiusPixels:{deprecatedFor:"pointSize"}};function jn(o){let{header:e,attributes:t}=o;if(!(!e||!t)&&(o.length=e.vertexCount,t.POSITION&&(t.instancePositions=t.POSITION),t.NORMAL&&(t.instanceNormals=t.NORMAL),t.COLOR_0)){let{size:i,value:n}=t.COLOR_0;t.instanceColors={size:i,type:"unorm8",value:n}}}var ve=class extends D.Layer{getShaders(){return super.getShaders({vs:Po,fs:_o,modules:[D.project32,D.gouraudLighting,D.picking]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceNormals:{size:3,transition:!0,accessor:"getNormal",defaultValue:Lo},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:Co}})}updateState(e){let{changeFlags:t,props:i}=e;super.updateState(e),t.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll()),t.dataChanged&&jn(i.data)}draw({uniforms:e}){let{pointSize:t,sizeUnits:i}=this.props,n=this.state.model;n.setUniforms(e),n.setUniforms({sizeUnits:D.UNIT[i],radiusPixels:t}),n.draw(this.context.renderPass)}_getModel(){let e=[];for(let t=0;t<3;t++){let i=t/3*Math.PI*2;e.push(Math.cos(i)*2,Math.sin(i)*2,0)}return new et.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new et.Geometry({topology:"triangle-list",attributes:{positions:new Float32Array(e)}}),isInstanced:!0})}};ve.layerName="PointCloudLayer";ve.defaultProps=Bn;var So=ve;var W=P(L(),1),Io=P(I(),1),Eo=P(I(),1);var wo=`#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radiusScale;
uniform float radiusMinPixels;
uniform float radiusMaxPixels;
uniform float lineWidthScale;
uniform float lineWidthMinPixels;
uniform float lineWidthMaxPixels;
uniform float stroked;
uniform bool filled;
uniform bool antialiasing;
uniform bool billboard;
uniform int radiusUnits;
uniform int lineWidthUnits;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),
radiusMinPixels, radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),
lineWidthMinPixels, lineWidthMaxPixels
);
outerRadiusPixels += stroked * lineWidthPixels / 2.0;
float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;
if (billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;var Mo=`#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
uniform bool filled;
uniform float stroked;
uniform bool antialiasing;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (stroked > 0.5) {
float isLine = antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (filled) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (!filled) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var To=[0,0,0,255],Vn={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:o=>o.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:To},getLineColor:{type:"accessor",value:To},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}},Pe=class extends W.Layer{getShaders(){return super.getShaders({vs:wo,fs:Mo,modules:[W.project32,W.picking]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){super.updateState(e),e.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:e}){let{radiusUnits:t,radiusScale:i,radiusMinPixels:n,radiusMaxPixels:r,stroked:s,filled:a,billboard:l,antialiasing:c,lineWidthUnits:u,lineWidthScale:f,lineWidthMinPixels:d,lineWidthMaxPixels:g}=this.props,p=this.state.model;p.setUniforms(e),p.setUniforms({stroked:s?1:0,filled:a,billboard:l,antialiasing:c,radiusUnits:W.UNIT[t],radiusScale:i,radiusMinPixels:n,radiusMaxPixels:r,lineWidthUnits:W.UNIT[u],lineWidthScale:f,lineWidthMinPixels:d,lineWidthMaxPixels:g}),p.draw(this.context.renderPass)}_getModel(){let e=[-1,-1,0,1,-1,0,-1,1,0,1,1,0];return new Eo.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new Io.Geometry({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array(e)}}}),isInstanced:!0})}};Pe.defaultProps=Vn;Pe.layerName="ScatterplotLayer";var tt=Pe;var b=P(L(),1),Et=P(I(),1);var Do=P(L(),1),No=P(I(),1);var oe={CLOCKWISE:1,COUNTER_CLOCKWISE:-1};function X(o,e,t={}){return Ao(o,t)!==e?(Zn(o,t),!0):!1}function Ao(o,e={}){return Math.sign(ot(o,e))}var Mt={x:0,y:1,z:2};function ot(o,e={}){let{start:t=0,end:i=o.length,plane:n="xy"}=e,r=e.size||2,s=0,a=Mt[n[0]],l=Mt[n[1]];for(let c=t,u=i-r;c<i;c+=r)s+=(o[c+a]-o[u+a])*(o[c+l]+o[u+l]),u=c;return s/2}function Zn(o,e){let{start:t=0,end:i=o.length,size:n=2}=e,r=(i-t)/n,s=Math.floor(r/2);for(let a=0;a<s;++a){let l=t+a*n,c=t+(r-1-a)*n;for(let u=0;u<n;++u){let f=o[l+u];o[l+u]=o[c+u],o[c+u]=f}}}function A(o,e){let t=e.length,i=o.length;if(i>0){let n=!0;for(let r=0;r<t;r++)if(o[i-t+r]!==e[r]){n=!1;break}if(n)return!1}for(let n=0;n<t;n++)o[i+n]=e[n];return!0}function _e(o,e){let t=e.length;for(let i=0;i<t;i++)o[i]=e[i]}function j(o,e,t,i,n=[]){let r=i+e*t;for(let s=0;s<t;s++)n[s]=o[r+s];return n}function it(o,e,t,i,n=[]){let r,s;if(t&8)r=(i[3]-o[1])/(e[1]-o[1]),s=3;else if(t&4)r=(i[1]-o[1])/(e[1]-o[1]),s=1;else if(t&2)r=(i[2]-o[0])/(e[0]-o[0]),s=2;else if(t&1)r=(i[0]-o[0])/(e[0]-o[0]),s=0;else return null;for(let a=0;a<o.length;a++)n[a]=(s&1)===a?i[s]:r*(e[a]-o[a])+o[a];return n}function Ce(o,e){let t=0;return o[0]<e[0]?t|=1:o[0]>e[2]&&(t|=2),o[1]<e[1]?t|=4:o[1]>e[3]&&(t|=8),t}function Le(o,e){let{size:t=2,broken:i=!1,gridResolution:n=10,gridOffset:r=[0,0],startIndex:s=0,endIndex:a=o.length}=e||{},l=(a-s)/t,c=[],u=[c],f=j(o,0,t,s),d,g,p=Oo(f,n,r,[]),h=[];A(c,f);for(let m=1;m<l;m++){for(d=j(o,m,t,s,d),g=Ce(d,p);g;){it(f,d,g,p,h);let y=Ce(h,p);y&&(it(f,h,y,p,h),g=y),A(c,h),_e(f,h),$n(p,n,g),i&&c.length>t&&(c=[],u.push(c),A(c,f)),g=Ce(d,p)}A(c,d),_e(f,d)}return i?u:u[0]}var bo=0,Kn=1;function Se(o,e=null,t){if(!o.length)return[];let{size:i=2,gridResolution:n=10,gridOffset:r=[0,0],edgeTypes:s=!1}=t||{},a=[],l=[{pos:o,types:s?new Array(o.length/i).fill(Kn):null,holes:e||[]}],c=[[],[]],u=[];for(;l.length;){let{pos:f,types:d,holes:g}=l.shift();Xn(f,i,g[0]||f.length,c),u=Oo(c[0],n,r,u);let p=Ce(c[1],u);if(p){let h=zo(f,d,i,0,g[0]||f.length,u,p),m={pos:h[0].pos,types:h[0].types,holes:[]},y={pos:h[1].pos,types:h[1].types,holes:[]};l.push(m,y);for(let _=0;_<g.length;_++)h=zo(f,d,i,g[_],g[_+1]||f.length,u,p),h[0]&&(m.holes.push(m.pos.length),m.pos=nt(m.pos,h[0].pos),s&&(m.types=nt(m.types,h[0].types))),h[1]&&(y.holes.push(y.pos.length),y.pos=nt(y.pos,h[1].pos),s&&(y.types=nt(y.types,h[1].types)))}else{let h={positions:f};s&&(h.edgeTypes=d),g.length&&(h.holeIndices=g),a.push(h)}}return a}function zo(o,e,t,i,n,r,s){let a=(n-i)/t,l=[],c=[],u=[],f=[],d=[],g,p,h,m=j(o,a-1,t,i),y=Math.sign(s&8?m[1]-r[3]:m[0]-r[2]),_=e&&e[a-1],x=0,v=0;for(let C=0;C<a;C++)g=j(o,C,t,i,g),p=Math.sign(s&8?g[1]-r[3]:g[0]-r[2]),h=e&&e[i/t+C],p&&y&&y!==p&&(it(m,g,s,r,d),A(l,d)&&u.push(_),A(c,d)&&f.push(_)),p<=0?(A(l,g)&&u.push(h),x-=p):u.length&&(u[u.length-1]=bo),p>=0?(A(c,g)&&f.push(h),v+=p):f.length&&(f[f.length-1]=bo),_e(m,g),y=p,_=h;return[x?{pos:l,types:e&&u}:null,v?{pos:c,types:e&&f}:null]}function Oo(o,e,t,i){let n=Math.floor((o[0]-t[0])/e)*e+t[0],r=Math.floor((o[1]-t[1])/e)*e+t[1];return i[0]=n,i[1]=r,i[2]=n+e,i[3]=r+e,i}function $n(o,e,t){t&8?(o[1]+=e,o[3]+=e):t&4?(o[1]-=e,o[3]-=e):t&2?(o[0]+=e,o[2]+=e):t&1&&(o[0]-=e,o[2]-=e)}function Xn(o,e,t,i){let n=1/0,r=-1/0,s=1/0,a=-1/0;for(let l=0;l<t;l+=e){let c=o[l],u=o[l+1];n=c<n?c:n,r=c>r?c:r,s=u<s?u:s,a=u>a?u:a}return i[0][0]=n,i[0][1]=s,i[1][0]=r,i[1][1]=a,i}function nt(o,e){for(let t=0;t<e.length;t++)o.push(e[t]);return o}var Yn=85.051129;function Tt(o,e){let{size:t=2,startIndex:i=0,endIndex:n=o.length,normalize:r=!0}=e||{},s=o.slice(i,n);Ro(s,t,0,n-i);let a=Le(s,{size:t,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(r)for(let l of a)Fo(l,t);return a}function It(o,e=null,t){let{size:i=2,normalize:n=!0,edgeTypes:r=!1}=t||{};e=e||[];let s=[],a=[],l=0,c=0;for(let f=0;f<=e.length;f++){let d=e[f]||o.length,g=c,p=Jn(o,i,l,d);for(let h=p;h<d;h++)s[c++]=o[h];for(let h=l;h<p;h++)s[c++]=o[h];Ro(s,i,g,c),qn(s,i,g,c,t?.maxLatitude),l=d,a[f]=c}a.pop();let u=Se(s,a,{size:i,gridResolution:360,gridOffset:[-180,-180],edgeTypes:r});if(n)for(let f of u)Fo(f.positions,i);return u}function Jn(o,e,t,i){let n=-1,r=-1;for(let s=t+1;s<i;s+=e){let a=Math.abs(o[s]);a>n&&(n=a,r=s-1)}return r}function qn(o,e,t,i,n=Yn){let r=o[t],s=o[i-e];if(Math.abs(r-s)>180){let a=j(o,0,e,t);a[0]+=Math.round((s-r)/360)*360,A(o,a),a[1]=Math.sign(a[1])*n,A(o,a),a[0]=r,A(o,a)}}function Ro(o,e,t,i){let n=o[0],r;for(let s=t;s<i;s+=e){r=o[s];let a=r-n;(a>180||a<-180)&&(r-=Math.round(a/360)*360),o[s]=n=r}}function Fo(o,e){let t,i=o.length/e;for(let r=0;r<i&&(t=o[r*e],(t+180)%360===0);r++);let n=-Math.round(t/360)*360;if(n!==0)for(let r=0;r<i;r++)o[r*e]+=n}var we=class extends No.Geometry{constructor(e){let{indices:t,attributes:i}=er(e);super({...e,indices:t,attributes:i})}};function er(o){let{radius:e,height:t=1,nradial:i=10}=o,{vertices:n}=o;n&&(Do.log.assert(n.length>=i),n=n.flatMap(g=>[g[0],g[1]]),X(n,oe.COUNTER_CLOCKWISE));let r=t>0,s=i+1,a=r?s*3+1:i,l=Math.PI*2/i,c=new Uint16Array(r?i*3*2:0),u=new Float32Array(a*3),f=new Float32Array(a*3),d=0;if(r){for(let g=0;g<s;g++){let p=g*l,h=g%i,m=Math.sin(p),y=Math.cos(p);for(let _=0;_<2;_++)u[d+0]=n?n[h*2]:y*e,u[d+1]=n?n[h*2+1]:m*e,u[d+2]=(1/2-_)*t,f[d+0]=n?n[h*2]:y,f[d+1]=n?n[h*2+1]:m,d+=3}u[d+0]=u[d-3],u[d+1]=u[d-2],u[d+2]=u[d-1],d+=3}for(let g=r?0:1;g<s;g++){let p=Math.floor(g/2)*Math.sign(.5-g%2),h=p*l,m=(p+i)%i,y=Math.sin(h),_=Math.cos(h);u[d+0]=n?n[m*2]:_*e,u[d+1]=n?n[m*2+1]:y*e,u[d+2]=t/2,f[d+2]=1,d+=3}if(r){let g=0;for(let p=0;p<i;p++)c[g++]=p*2+0,c[g++]=p*2+2,c[g++]=p*2+0,c[g++]=p*2+1,c[g++]=p*2+1,c[g++]=p*2+3}return{indices:c,attributes:{POSITION:{size:3,value:u},NORMAL:{size:3,value:f}}}}var ko=`#version 300 es
#define SHADER_NAME column-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radius;
uniform float angle;
uniform vec2 offset;
uniform bool extruded;
uniform bool stroked;
uniform bool isStroke;
uniform float coverage;
uniform float elevationScale;
uniform float edgeDistance;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int radiusUnits;
uniform int widthUnits;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec4 position_commonspace;
#endif
void main(void) {
geometry.worldPosition = instancePositions;
vec4 color = isStroke ? instanceLineColors : instanceFillColors;
mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;
} else if (stroked) {
float widthPixels = clamp(
project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels) / 2.0;
float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);
if (isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float dotRadius = radius * coverage * shouldRender;
geometry.pickingColor = instancePickingColors;
vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
vec3 centroidPosition64Low = instancePositions64Low;
vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;
if (radiusUnits == UNIT_METERS) {
offset = project_size(offset);
}
vec3 pos = vec3(offset, 0.);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (extruded && !isStroke) {
#ifdef FLAT_SHADING
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var Wo=`#version 300 es
#define SHADER_NAME column-layer-fragment-shader
precision highp float;
uniform vec3 project_uCameraPosition;
uniform bool extruded;
uniform bool isStroke;
out vec4 fragColor;
in vec4 vColor;
#ifdef FLAT_SHADING
in vec4 position_commonspace;
#endif
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
#ifdef FLAT_SHADING
if (extruded && !isStroke && !bool(picking.isActive)) {
vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);
}
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var rt=[0,0,0,255],tr={diskResolution:{type:"number",min:4,value:20},vertices:null,radius:{type:"number",min:0,value:1e3},angle:{type:"number",value:0},offset:{type:"array",value:[0,0]},coverage:{type:"number",min:0,max:1,value:1},elevationScale:{type:"number",min:0,value:1},radiusUnits:"meters",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,extruded:!0,wireframe:!1,filled:!0,stroked:!1,flatShading:!1,getPosition:{type:"accessor",value:o=>o.position},getFillColor:{type:"accessor",value:rt},getLineColor:{type:"accessor",value:rt},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0,getColor:{deprecatedFor:["getFillColor","getLineColor"]}},Me=class extends b.Layer{getShaders(){let e={},{flatShading:t}=this.props;return t&&(e.FLAT_SHADING=1),super.getShaders({vs:ko,fs:Wo,defines:e,modules:[b.project32,t?b.phongLighting:b.gouraudLighting,b.picking]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceElevations:{size:1,transition:!0,accessor:"getElevation"},instanceFillColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getFillColor",defaultValue:rt},instanceLineColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getLineColor",defaultValue:rt},instanceStrokeWidths:{size:1,accessor:"getLineWidth",transition:!0}})}updateState(e){super.updateState(e);let{props:t,oldProps:i,changeFlags:n}=e,r=n.extensionsChanged||t.flatShading!==i.flatShading;r&&(this.state.models?.forEach(a=>a.destroy()),this.setState(this._getModels()),this.getAttributeManager().invalidateAll());let s=this.getNumInstances();this.state.fillModel.setInstanceCount(s),this.state.wireframeModel.setInstanceCount(s),(r||t.diskResolution!==i.diskResolution||t.vertices!==i.vertices||(t.extruded||t.stroked)!==(i.extruded||i.stroked))&&this._updateGeometry(t)}getGeometry(e,t,i){let n=new we({radius:1,height:i?2:0,vertices:t,nradial:e}),r=0;if(t)for(let s=0;s<e;s++){let a=t[s],l=Math.sqrt(a[0]*a[0]+a[1]*a[1]);r+=l/e}else r=1;return this.setState({edgeDistance:Math.cos(Math.PI/e)*r}),n}_getModels(){let e=this.getShaders(),t=this.getAttributeManager().getBufferLayouts(),i=new Et.Model(this.context.device,{...e,id:`${this.props.id}-fill`,bufferLayout:t,isInstanced:!0}),n=new Et.Model(this.context.device,{...e,id:`${this.props.id}-wireframe`,bufferLayout:t,isInstanced:!0});return{fillModel:i,wireframeModel:n,models:[n,i]}}_updateGeometry({diskResolution:e,vertices:t,extruded:i,stroked:n}){let r=this.getGeometry(e,t,i||n);this.setState({fillVertexCount:r.attributes.POSITION.value.length/3});let s=this.state.fillModel,a=this.state.wireframeModel;s.setGeometry(r),s.setTopology("triangle-strip"),s.setIndexBuffer(null),a.setGeometry(r),a.setTopology("line-list")}draw({uniforms:e}){let{lineWidthUnits:t,lineWidthScale:i,lineWidthMinPixels:n,lineWidthMaxPixels:r,radiusUnits:s,elevationScale:a,extruded:l,filled:c,stroked:u,wireframe:f,offset:d,coverage:g,radius:p,angle:h}=this.props,m=this.state.fillModel,y=this.state.wireframeModel,{fillVertexCount:_,edgeDistance:x}=this.state,v={...e,radius:p,angle:h/180*Math.PI,offset:d,extruded:l,stroked:u,coverage:g,elevationScale:a,edgeDistance:x,radiusUnits:b.UNIT[s],widthUnits:b.UNIT[t],widthScale:i,widthMinPixels:n,widthMaxPixels:r};l&&f&&(y.setUniforms(v),y.setUniforms({isStroke:!0}),y.draw(this.context.renderPass)),m.setUniforms(v),c&&(m.setVertexCount(_),m.setUniforms({isStroke:!1}),m.draw(this.context.renderPass)),!l&&u&&(m.setVertexCount(_*2/3),m.setUniforms({isStroke:!0}),m.draw(this.context.renderPass))}};Me.layerName="ColumnLayer";Me.defaultProps=tr;var st=Me;var Uo=P(L(),1),Go=P(I(),1);var or={cellSize:{type:"number",min:0,value:1e3},offset:{type:"array",value:[1,1]}},Te=class extends st{_updateGeometry(){let e=new Go.CubeGeometry;this.state.fillModel.setGeometry(e)}draw({uniforms:e}){let{elevationScale:t,extruded:i,offset:n,coverage:r,cellSize:s,angle:a,radiusUnits:l}=this.props,c=this.state.fillModel;c.setUniforms(e),c.setUniforms({radius:s/2,radiusUnits:Uo.UNIT[l],angle:a,offset:n,extruded:i,coverage:r,elevationScale:t,edgeDistance:1,isStroke:!1}),c.draw(this.context.renderPass)}};Te.layerName="GridCellLayer";Te.defaultProps=or;var Bo=Te;var V=P(L(),1),$o=P(I(),1),Xo=P(I(),1);var Zo=P(L(),1);function jo(o,e,t,i){let n;if(Array.isArray(o[0])){let r=o.length*e;n=new Array(r);for(let s=0;s<o.length;s++)for(let a=0;a<e;a++)n[s*e+a]=o[s][a]||0}else n=o;return t?Le(n,{size:e,gridResolution:t}):i?Tt(n,{size:e}):n}var ir=1,nr=2,At=4,Ie=class extends Zo.Tesselator{constructor(e){super({...e,attributes:{positions:{size:3,padding:18,initialize:!0,type:e.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(e){return this.attributes[e]}getGeometryFromBuffer(e){return this.normalize?super.getGeometryFromBuffer(e):null}normalizeGeometry(e){return this.normalize?jo(e,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):e}getGeometrySize(e){if(Vo(e)){let i=0;for(let n of e)i+=this.getGeometrySize(n);return i}let t=this.getPathLength(e);return t<2?0:this.isClosed(e)?t<3?0:t+2:t}updateGeometryAttributes(e,t){if(t.geometrySize!==0)if(e&&Vo(e))for(let i of e){let n=this.getGeometrySize(i);t.geometrySize=n,this.updateGeometryAttributes(i,t),t.vertexStart+=n}else this._updateSegmentTypes(e,t),this._updatePositions(e,t)}_updateSegmentTypes(e,t){let i=this.attributes.segmentTypes,n=e?this.isClosed(e):!1,{vertexStart:r,geometrySize:s}=t;i.fill(0,r,r+s),n?(i[r]=At,i[r+s-2]=At):(i[r]+=ir,i[r+s-2]+=nr),i[r+s-1]=At}_updatePositions(e,t){let{positions:i}=this.attributes;if(!i||!e)return;let{vertexStart:n,geometrySize:r}=t,s=new Array(3);for(let a=n,l=0;l<r;a++,l++)this.getPointOnPath(e,l,s),i[a*3]=s[0],i[a*3+1]=s[1],i[a*3+2]=s[2]}getPathLength(e){return e.length/this.positionSize}getPointOnPath(e,t,i=[]){let{positionSize:n}=this;t*n>=e.length&&(t+=1-e.length/n);let r=t*n;return i[0]=e[r],i[1]=e[r+1],i[2]=n===3&&e[r+2]||0,i}isClosed(e){if(!this.normalize)return Boolean(this.opts.loop);let{positionSize:t}=this,i=e.length-t;return e[0]===e[i]&&e[1]===e[i+1]&&(t===2||e[2]===e[i+2])}};function Vo(o){return Array.isArray(o[0])}var Ho=`#version 300 es
#define SHADER_NAME path-layer-vertex-shader
in vec2 positions;
in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float jointType;
uniform float capType;
uniform float miterLimit;
uniform bool billboard;
uniform int widthUnits;
uniform float opacity;
out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;
const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);
float flipIfTrue(bool flag) {
return -(float(flag) * 2. - 1.);
}
vec3 getLineJoinOffset(
vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
vec2 width
) {
bool isEnd = positions.x > 0.0;
float sideOfPath = positions.y;
float isJoint = float(sideOfPath == 0.0);
vec3 deltaA3 = (currPoint - prevPoint);
vec3 deltaB3 = (nextPoint - currPoint);
mat3 rotationMatrix;
bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);
if (needsRotation) {
deltaA3 = deltaA3 * rotationMatrix;
deltaB3 = deltaB3 * rotationMatrix;
}
vec2 deltaA = deltaA3.xy / width;
vec2 deltaB = deltaB3.xy / width;
float lenA = length(deltaA);
float lenB = length(deltaB);
vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);
vec2 perpA = vec2(-dirA.y, dirA.x);
vec2 perpB = vec2(-dirB.y, dirB.x);
vec2 tangent = dirA + dirB;
tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
vec2 miterVec = vec2(-tangent.y, tangent.x);
vec2 dir = isEnd ? dirA : dirB;
vec2 perp = isEnd ? perpA : perpB;
float L = isEnd ? lenA : lenB;
float sinHalfA = abs(dot(miterVec, perp));
float cosHalfA = abs(dot(dirA, miterVec));
float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
float cornerPosition = sideOfPath * turnDirection;
float miterSize = 1.0 / max(sinHalfA, EPSILON);
miterSize = mix(
min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
miterSize,
step(0.0, cornerPosition)
);
vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
* (sideOfPath + isJoint * turnDirection);
bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
bool isCap = isStartCap || isEndCap;
if (isCap) {
offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);
vJointType = capType;
} else {
vJointType = jointType;
}
vPathLength = L;
vCornerOffset = offsetVec;
vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
vMiterLength = isCap ? isJoint : vMiterLength;
vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
vPathPosition = vec2(
dot(offsetFromStartOfPath, perp),
dot(offsetFromStartOfPath, dir)
);
geometry.uv = vPathPosition;
float isValid = step(instanceTypes, 3.5);
vec3 offset = vec3(offsetVec * width * isValid, 0.0);
if (needsRotation) {
offset = rotationMatrix * offset;
}
return offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
if (position.w < EPSILON) {
float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
position = refPosition + (position - refPosition) * r;
}
}
void main() {
geometry.pickingColor = instancePickingColors;
vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
float isEnd = positions.x;
vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);
vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);
vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);
geometry.worldPosition = currPosition;
vec2 widthPixels = vec2(clamp(
project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels) / 2.0);
vec3 width;
if (billboard) {
vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);
clipLine(prevPositionScreen, currPositionScreen);
clipLine(nextPositionScreen, currPositionScreen);
clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));
width = vec3(widthPixels, 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(
prevPositionScreen.xyz / prevPositionScreen.w,
currPositionScreen.xyz / currPositionScreen.w,
nextPositionScreen.xyz / nextPositionScreen.w,
project_pixel_size_to_clipspace(width.xy)
);
DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
} else {
prevPosition = project_position(prevPosition, prevPosition64Low);
currPosition = project_position(currPosition, currPosition64Low);
nextPosition = project_position(nextPosition, nextPosition64Low);
width = vec3(project_pixel_size(widthPixels), 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
geometry.position = vec4(currPosition + offset, 1.0);
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var Ko=`#version 300 es
#define SHADER_NAME path-layer-fragment-shader
precision highp float;
uniform float miterLimit;
in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;
out vec4 fragColor;
void main(void) {
geometry.uv = vPathPosition;
if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
discard;
}
if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {
discard;
}
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Yo=[0,0,0,255],rr={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:o=>o.path},getColor:{type:"accessor",value:Yo},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},bt={enter:(o,e)=>e.length?e.subarray(e.length-o.length):o},Ee=class extends V.Layer{getShaders(){return super.getShaders({vs:Ho,fs:Ko,modules:[V.project32,V.picking]})}get wrapLongitude(){return!1}getBounds(){return this.getAttributeManager()?.getBounds(["vertexPositions"])}initializeState(){this.getAttributeManager().addInstanced({vertexPositions:{size:3,vertexOffset:1,type:"float64",fp64:this.use64bitPositions(),transition:bt,accessor:"getPath",update:this.calculatePositions,noAlloc:!0,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:"uint8",update:this.calculateSegmentTypes,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:bt,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",accessor:"getColor",transition:bt,defaultValue:Yo},instancePickingColors:{size:4,type:"uint8",accessor:(i,{index:n,target:r})=>this.encodePickingColor(i&&i.__source?i.__source.index:n,r)}}),this.setState({pathTesselator:new Ie({fp64:this.use64bitPositions()})})}updateState(e){super.updateState(e);let{props:t,changeFlags:i}=e,n=this.getAttributeManager();if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPath)){let{pathTesselator:s}=this.state,a=t.data.attributes||{};s.updateGeometry({data:t.data,geometryBuffer:a.getPath,buffers:a,normalize:!t._pathType,loop:t._pathType==="loop",getGeometry:t.getPath,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:i.dataChanged}),this.setState({numInstances:s.instanceCount,startIndices:s.vertexStarts}),i.dataChanged||n.invalidateAll()}i.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),n.invalidateAll())}getPickingInfo(e){let t=super.getPickingInfo(e),{index:i}=t,n=this.props.data;return n[0]&&n[0].__source&&(t.object=n.find(r=>r.__source.index===i)),t}disablePickingIndex(e){let t=this.props.data;if(t[0]&&t[0].__source)for(let i=0;i<t.length;i++)t[i].__source.index===e&&this._disablePickingIndex(i);else super.disablePickingIndex(e)}draw({uniforms:e}){let{jointRounded:t,capRounded:i,billboard:n,miterLimit:r,widthUnits:s,widthScale:a,widthMinPixels:l,widthMaxPixels:c}=this.props,u=this.state.model;u.setUniforms(e),u.setUniforms({jointType:Number(t),capType:Number(i),billboard:n,widthUnits:V.UNIT[s],widthScale:a,miterLimit:r,widthMinPixels:l,widthMaxPixels:c}),u.draw(this.context.renderPass)}_getModel(){let e=[0,1,2,1,4,2,1,3,4,3,5,4],t=[0,0,0,-1,0,1,1,-1,1,1,1,0];return new Xo.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new $o.Geometry({topology:"triangle-list",attributes:{indices:new Uint16Array(e),positions:{value:new Float32Array(t),size:2}}}),isInstanced:!0})}calculatePositions(e){let{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateSegmentTypes(e){let{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("segmentTypes")}};Ee.defaultProps=rr;Ee.layerName="PathLayer";var ie=Ee;var ae=P(L(),1);var z=P(L(),1),J=P(I(),1);var si=P(ti(),1);var ft=oe.CLOCKWISE,oi=oe.COUNTER_CLOCKWISE,Z={isClosed:!0};function _r(o){if(o=o&&o.positions||o,!Array.isArray(o)&&!ArrayBuffer.isView(o))throw new Error("invalid polygon")}function re(o){return"positions"in o?o.positions:o}function Oe(o){return"holeIndices"in o?o.holeIndices:null}function Cr(o){return Array.isArray(o[0])}function Lr(o){return o.length>=1&&o[0].length>=2&&Number.isFinite(o[0][0])}function Sr(o){let e=o[0],t=o[o.length-1];return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function wr(o,e,t,i){for(let n=0;n<e;n++)if(o[t+n]!==o[i-e+n])return!1;return!0}function ii(o,e,t,i,n){let r=e,s=t.length;for(let a=0;a<s;a++)for(let l=0;l<i;l++)o[r++]=t[a][l]||0;if(!Sr(t))for(let a=0;a<i;a++)o[r++]=t[0][a]||0;return Z.start=e,Z.end=r,Z.size=i,X(o,n,Z),r}function ni(o,e,t,i,n=0,r,s){r=r||t.length;let a=r-n;if(a<=0)return e;let l=e;for(let c=0;c<a;c++)o[l++]=t[n+c];if(!wr(t,i,n,r))for(let c=0;c<i;c++)o[l++]=t[n+c];return Z.start=e,Z.end=l,Z.size=i,X(o,s,Z),l}function dt(o,e){_r(o);let t=[],i=[];if("positions"in o){let{positions:n,holeIndices:r}=o;if(r){let s=0;for(let a=0;a<=r.length;a++)s=ni(t,s,n,e,r[a-1],r[a],a===0?ft:oi),i.push(s);return i.pop(),{positions:t,holeIndices:i}}o=n}if(!Cr(o))return ni(t,0,o,e,0,t.length,ft),t;if(!Lr(o)){let n=0;for(let[r,s]of o.entries())n=ii(t,n,s,e,r===0?ft:oi),i.push(n);return i.pop(),{positions:t,holeIndices:i}}return ii(t,0,o,e,ft),t}function Dt(o,e,t){let i=o.length/3,n=0;for(let r=0;r<i;r++){let s=(r+1)%i;n+=o[r*3+e]*o[s*3+t],n-=o[s*3+e]*o[r*3+t]}return Math.abs(n/2)}function ri(o,e,t,i){let n=o.length/3;for(let r=0;r<n;r++){let s=r*3,a=o[s+0],l=o[s+1],c=o[s+2];o[s+e]=a,o[s+t]=l,o[s+i]=c}}function ai(o,e,t,i){let n=Oe(o);n&&(n=n.map(a=>a/e));let r=re(o),s=i&&e===3;if(t){let a=r.length;r=r.slice();let l=[];for(let c=0;c<a;c+=e){l[0]=r[c],l[1]=r[c+1],s&&(l[2]=r[c+2]);let u=t(l);r[c]=u[0],r[c+1]=u[1],s&&(r[c+2]=u[2])}}if(s){let a=Dt(r,0,1),l=Dt(r,0,2),c=Dt(r,1,2);if(!a&&!l&&!c)return[];a>l&&a>c||(l>c?(t||(r=r.slice()),ri(r,0,2,1)):(t||(r=r.slice()),ri(r,2,0,1)))}return(0,si.default)(r,n,e)}var ui=P(L(),1);var Re=class extends ui.Tesselator{constructor(e){let{fp64:t,IndexType:i=Uint32Array}=e;super({...e,attributes:{positions:{size:3,type:t?Float64Array:Float32Array},vertexValid:{type:Uint16Array,size:1},indices:{type:i,size:1}}})}get(e){let{attributes:t}=this;return e==="indices"?t.indices&&t.indices.subarray(0,this.vertexCount):t[e]}updateGeometry(e){super.updateGeometry(e);let t=this.buffers.indices;if(t)this.vertexCount=(t.value||t).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(e){if(this.normalize){let t=dt(e,this.positionSize);return this.opts.resolution?Se(re(t),Oe(t),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?It(re(t),Oe(t),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):t}return e}getGeometrySize(e){if(ci(e)){let t=0;for(let i of e)t+=this.getGeometrySize(i);return t}return re(e).length/this.positionSize}getGeometryFromBuffer(e){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(e):null}updateGeometryAttributes(e,t){if(e&&ci(e))for(let i of e){let n=this.getGeometrySize(i);t.geometrySize=n,this.updateGeometryAttributes(i,t),t.vertexStart+=n,t.indexStart=this.indexStarts[t.geometryIndex+1]}else{let i=e;this._updateIndices(i,t),this._updatePositions(i,t),this._updateVertexValid(i,t)}}_updateIndices(e,{geometryIndex:t,vertexStart:i,indexStart:n}){let{attributes:r,indexStarts:s,typedArrayManager:a}=this,l=r.indices;if(!l||!e)return;let c=n,u=ai(e,this.positionSize,this.opts.preproject,this.opts.full3d);l=a.allocate(l,n+u.length,{copy:!0});for(let f=0;f<u.length;f++)l[c++]=u[f]+i;s[t+1]=n+u.length,r.indices=l}_updatePositions(e,{vertexStart:t,geometrySize:i}){let{attributes:{positions:n},positionSize:r}=this;if(!n||!e)return;let s=re(e);for(let a=t,l=0;l<i;a++,l++){let c=s[l*r],u=s[l*r+1],f=r>2?s[l*r+2]:0;n[a*3]=c,n[a*3+1]=u,n[a*3+2]=f}}_updateVertexValid(e,{vertexStart:t,geometrySize:i}){let{positionSize:n}=this,r=this.attributes.vertexValid,s=e&&Oe(e);if(e&&e.edgeTypes?r.set(e.edgeTypes,t):r.fill(1,t,t+i),s)for(let a=0;a<s.length;a++)r[t+s[a]/n-1]=0;r[t+i-1]=0}};function ci(o){return Array.isArray(o)&&o.length>0&&!Number.isFinite(o[0])}var gt=`uniform bool extruded;
uniform bool isWireframe;
uniform float elevationScale;
uniform float opacity;
in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;
out vec4 vColor;
struct PolygonProps {
vec3 positions;
vec3 positions64Low;
vec3 normal;
float elevations;
};
vec3 project_offset_normal(vec3 vector) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
return normalize(vector * project_uCommonUnitsPerWorldUnit);
}
return project_normal(vector);
}
void calculatePosition(PolygonProps props) {
vec3 pos = props.positions;
vec3 pos64Low = props.positions64Low;
vec3 normal = props.normal;
vec4 colors = isWireframe ? lineColors : fillColors;
geometry.worldPosition = props.positions;
geometry.pickingColor = pickingColors;
if (extruded) {
pos.z += props.elevations * elevationScale;
}
gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (extruded) {
#ifdef IS_SIDE_VERTEX
normal = project_offset_normal(normal);
#else
normal = project_normal(normal);
#endif
geometry.normal = normal;
vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, colors.a * opacity);
} else {
vColor = vec4(colors.rgb, colors.a * opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var fi=`#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader
in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
${gt}
void main(void) {
PolygonProps props;
props.positions = vertexPositions;
props.positions64Low = vertexPositions64Low;
props.elevations = elevations;
props.normal = vec3(0.0, 0.0, 1.0);
calculatePosition(props);
}
`;var di=`#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX
in vec2 positions;
in vec3 vertexPositions;
in vec3 nextVertexPositions;
in vec3 vertexPositions64Low;
in vec3 nextVertexPositions64Low;
in float elevations;
in float instanceVertexValid;
${gt}
void main(void) {
if(instanceVertexValid < 0.5){
gl_Position = vec4(0.);
return;
}
PolygonProps props;
vec3 pos;
vec3 pos64Low;
vec3 nextPos;
vec3 nextPos64Low;
#if RING_WINDING_ORDER_CW == 1
pos = vertexPositions;
pos64Low = vertexPositions64Low;
nextPos = nextVertexPositions;
nextPos64Low = nextVertexPositions64Low;
#else
pos = nextVertexPositions;
pos64Low = nextVertexPositions64Low;
nextPos = vertexPositions;
nextPos64Low = vertexPositions64Low;
#endif
props.positions = mix(pos, nextPos, positions.x);
props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);
props.normal = vec3(
pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
0.0);
props.elevations = elevations * positions.y;
calculatePosition(props);
}
`;var gi=`#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var ht=[0,0,0,255],Mr={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",_full3d:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:o=>o.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:ht},getLineColor:{type:"accessor",value:ht},material:!0},pt={enter:(o,e)=>e.length?e.subarray(e.length-o.length):o},Fe=class extends z.Layer{getShaders(e){return super.getShaders({vs:e==="top"?fi:di,fs:gi,defines:{RING_WINDING_ORDER_CW:!this.props._normalize&&this.props._windingOrder==="CCW"?0:1},modules:[z.project32,z.gouraudLighting,z.picking]})}get wrapLongitude(){return!1}getBounds(){return this.getAttributeManager()?.getBounds(["vertexPositions"])}initializeState(){let{viewport:e}=this.context,{coordinateSystem:t}=this.props,{_full3d:i}=this.props;e.isGeospatial&&t===z.COORDINATE_SYSTEM.DEFAULT&&(t=z.COORDINATE_SYSTEM.LNGLAT);let n;t===z.COORDINATE_SYSTEM.LNGLAT&&(i?n=e.projectPosition.bind(e):n=e.projectFlat.bind(e)),this.setState({numInstances:0,polygonTesselator:new Re({preproject:n,fp64:this.use64bitPositions(),IndexType:Uint32Array})});let r=this.getAttributeManager(),s=!0;r.remove(["instancePickingColors"]),r.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:s},vertexPositions:{size:3,type:"float64",stepMode:"dynamic",fp64:this.use64bitPositions(),transition:pt,accessor:"getPolygon",update:this.calculatePositions,noAlloc:s,shaderAttributes:{nextVertexPositions:{vertexOffset:1}}},instanceVertexValid:{size:1,type:"uint16",stepMode:"instance",update:this.calculateVertexValid,noAlloc:s},elevations:{size:1,stepMode:"dynamic",transition:pt,accessor:"getElevation"},fillColors:{size:this.props.colorFormat.length,type:"unorm8",stepMode:"dynamic",transition:pt,accessor:"getFillColor",defaultValue:ht},lineColors:{size:this.props.colorFormat.length,type:"unorm8",stepMode:"dynamic",transition:pt,accessor:"getLineColor",defaultValue:ht},pickingColors:{size:4,type:"uint8",stepMode:"dynamic",accessor:(a,{index:l,target:c})=>this.encodePickingColor(a&&a.__source?a.__source.index:l,c)}})}getPickingInfo(e){let t=super.getPickingInfo(e),{index:i}=t,n=this.props.data;return n[0]&&n[0].__source&&(t.object=n.find(r=>r.__source.index===i)),t}disablePickingIndex(e){let t=this.props.data;if(t[0]&&t[0].__source)for(let i=0;i<t.length;i++)t[i].__source.index===e&&this._disablePickingIndex(i);else super.disablePickingIndex(e)}draw({uniforms:e}){let{extruded:t,filled:i,wireframe:n,elevationScale:r}=this.props,{topModel:s,sideModel:a,wireframeModel:l,polygonTesselator:c}=this.state,u={...e,extruded:Boolean(t),elevationScale:r};l&&n&&(l.setInstanceCount(c.instanceCount-1),l.setUniforms(u),l.draw(this.context.renderPass)),a&&i&&(a.setInstanceCount(c.instanceCount-1),a.setUniforms(u),a.draw(this.context.renderPass)),s&&i&&(s.setVertexCount(c.vertexCount),s.setUniforms(u),s.draw(this.context.renderPass))}updateState(e){super.updateState(e),this.updateGeometry(e);let{props:t,oldProps:i,changeFlags:n}=e,r=this.getAttributeManager();(n.extensionsChanged||t.filled!==i.filled||t.extruded!==i.extruded)&&(this.state.models?.forEach(a=>a.destroy()),this.setState(this._getModels()),r.invalidateAll())}updateGeometry({props:e,oldProps:t,changeFlags:i}){if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPolygon)){let{polygonTesselator:r}=this.state,s=e.data.attributes||{};r.updateGeometry({data:e.data,normalize:e._normalize,geometryBuffer:s.getPolygon,buffers:s,getGeometry:e.getPolygon,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:i.dataChanged,full3d:e._full3d}),this.setState({numInstances:r.instanceCount,startIndices:r.vertexStarts}),i.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(){let{id:e,filled:t,extruded:i}=this.props,n,r,s;if(t){let a=this.getShaders("top");a.defines.NON_INSTANCED_MODEL=1;let l=this.getAttributeManager().getBufferLayouts({isInstanced:!1});n=new J.Model(this.context.device,{...a,id:`${e}-top`,topology:"triangle-list",uniforms:{isWireframe:!1},bufferLayout:l,isIndexed:!0,userData:{excludeAttributes:{instanceVertexValid:!0}}})}if(i){let a=this.getAttributeManager().getBufferLayouts({isInstanced:!0});r=new J.Model(this.context.device,{...this.getShaders("side"),id:`${e}-side`,bufferLayout:a,uniforms:{isWireframe:!1},geometry:new J.Geometry({topology:"triangle-strip",attributes:{positions:{size:2,value:new Float32Array([1,0,0,0,1,1,0,1])}}}),isInstanced:!0,userData:{excludeAttributes:{indices:!0}}}),s=new J.Model(this.context.device,{...this.getShaders("side"),id:`${e}-wireframe`,bufferLayout:a,uniforms:{isWireframe:!0},geometry:new J.Geometry({topology:"line-strip",attributes:{positions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),isInstanced:!0,userData:{excludeAttributes:{indices:!0}}})}return{models:[r,s,n].filter(Boolean),topModel:n,sideModel:r,wireframeModel:s}}calculateIndices(e){let{polygonTesselator:t}=this.state;e.startIndices=t.indexStarts,e.value=t.get("indices")}calculatePositions(e){let{polygonTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateVertexValid(e){e.value=this.state.polygonTesselator.get("vertexValid")}};Fe.defaultProps=Mr;Fe.layerName="SolidPolygonLayer";var se=Fe;function mt({data:o,getIndex:e,dataRange:t,replace:i}){let{startRow:n=0,endRow:r=1/0}=t,s=o.length,a=s,l=s;for(let d=0;d<s;d++){let g=e(o[d]);if(a>d&&g>=n&&(a=d),g>=r){l=d;break}}let c=a,f=l-a!==i.length?o.slice(l):void 0;for(let d=0;d<i.length;d++)o[c++]=i[d];if(f){for(let d=0;d<f.length;d++)o[c++]=f[d];o.length=c}return{startRow:a,endRow:a+i.length}}var pi=[0,0,0,255],Tr=[0,0,0,255],Ir={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:o=>o.polygon},getFillColor:{type:"accessor",value:Tr},getLineColor:{type:"accessor",value:pi},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0},De=class extends ae.CompositeLayer{initializeState(){this.state={paths:[],pathsDiff:null},this.props.getLineDashArray&&ae.log.removed("getLineDashArray","PathStyleExtension")()}updateState({changeFlags:e}){let t=e.dataChanged||e.updateTriggersChanged&&(e.updateTriggersChanged.all||e.updateTriggersChanged.getPolygon);if(t&&Array.isArray(e.dataChanged)){let i=this.state.paths.slice(),n=e.dataChanged.map(r=>mt({data:i,getIndex:s=>s.__source.index,dataRange:r,replace:this._getPaths(r)}));this.setState({paths:i,pathsDiff:n})}else t&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(e={}){let{data:t,getPolygon:i,positionFormat:n,_normalize:r}=this.props,s=[],a=n==="XY"?2:3,{startRow:l,endRow:c}=e,{iterable:u,objectInfo:f}=(0,ae.createIterable)(t,l,c);for(let d of u){f.index++;let g=i(d,f);r&&(g=dt(g,a));let{holeIndices:p}=g,h=g.positions||g;if(p)for(let m=0;m<=p.length;m++){let y=h.slice(p[m-1]||0,p[m]||h.length);s.push(this.getSubLayerRow({path:y},d,f.index))}else s.push(this.getSubLayerRow({path:h},d,f.index))}return s}renderLayers(){let{data:e,_dataDiff:t,stroked:i,filled:n,extruded:r,wireframe:s,_normalize:a,_windingOrder:l,elevationScale:c,transitions:u,positionFormat:f}=this.props,{lineWidthUnits:d,lineWidthScale:g,lineWidthMinPixels:p,lineWidthMaxPixels:h,lineJointRounded:m,lineMiterLimit:y,lineDashJustified:_}=this.props,{getFillColor:x,getLineColor:v,getLineWidth:C,getLineDashArray:M,getElevation:N,getPolygon:O,updateTriggers:T,material:He}=this.props,{paths:Q,pathsDiff:E}=this.state,w=this.getSubLayerClass("fill",se),St=this.getSubLayerClass("stroke",ie),Ke=this.shouldRenderSubLayer("fill",Q)&&new w({_dataDiff:t,extruded:r,elevationScale:c,filled:n,wireframe:s,_normalize:a,_windingOrder:l,getElevation:N,getFillColor:x,getLineColor:r&&s?v:pi,material:He,transitions:u},this.getSubLayerProps({id:"fill",updateTriggers:T&&{getPolygon:T.getPolygon,getElevation:T.getElevation,getFillColor:T.getFillColor,lineColors:r&&s,getLineColor:T.getLineColor}}),{data:e,positionFormat:f,getPolygon:O}),Xi=!r&&i&&this.shouldRenderSubLayer("stroke",Q)&&new St({_dataDiff:E&&(()=>E),widthUnits:d,widthScale:g,widthMinPixels:p,widthMaxPixels:h,jointRounded:m,miterLimit:y,dashJustified:_,_pathType:"loop",transitions:u&&{getWidth:u.getLineWidth,getColor:u.getLineColor,getPath:u.getPolygon},getColor:this.getSubLayerAccessor(v),getWidth:this.getSubLayerAccessor(C),getDashArray:this.getSubLayerAccessor(M)},this.getSubLayerProps({id:"stroke",updateTriggers:T&&{getWidth:T.getLineWidth,getColor:T.getLineColor,getDashArray:T.getLineDashArray}}),{data:Q,positionFormat:f,getPath:Yi=>Yi.path});return[!r&&Ke,Xi,r&&Ke]}};De.layerName="PolygonLayer";De.defaultProps=Ir;var hi=De;var Ki=P(L(),1);function mi(o,e){if(!o)return null;let t="startIndices"in o?o.startIndices[e]:e,i=o.featureIds.value[t];return t!==-1?Er(o,i,t):null}function Er(o,e,t){let i={properties:{...o.properties[e]}};for(let n in o.numericProps)i.properties[n]=o.numericProps[n].value[t];return i}function xi(o,e){let t={points:null,lines:null,polygons:null};for(let i in t){let n=o[i].globalFeatureIds.value;t[i]=new Uint8ClampedArray(n.length*4);let r=[];for(let s=0;s<n.length;s++)e(n[s],r),t[i][s*4+0]=r[0],t[i][s*4+1]=r[1],t[i][s*4+2]=r[2],t[i][s*4+3]=255}return t}var ce=P(L(),1);var Pi=P(L(),1);var yi=`#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D iconsTexture;
uniform float gamma;
uniform bool sdf;
uniform float alphaCutoff;
uniform float sdfBuffer;
uniform float outlineBuffer;
uniform vec4 outlineColor;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
if (!bool(picking.isActive)) {
float alpha = texture(iconsTexture, vTextureCoords).a;
vec4 color = vColor;
if (sdf) {
float distance = alpha;
alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);
if (outlineBuffer > 0.0) {
float inFill = alpha;
float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);
color = mix(outlineColor, vColor, inFill);
alpha = inBorder;
}
}
float a = alpha * color.a;
if (a < alphaCutoff) {
discard;
}
fragColor = vec4(color.rgb, a * opacity);
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Nt=192/256,vi=[],Ar={getIconOffsets:{type:"accessor",value:o=>o.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}},Ne=class extends te{getShaders(){return{...super.getShaders(),fs:yi}}initializeState(){super.initializeState(),this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:"uint8",size:3,accessor:(t,{index:i,target:n})=>this.encodePickingColor(i,n)}})}updateState(e){super.updateState(e);let{props:t,oldProps:i}=e,{outlineColor:n}=t;n!==i.outlineColor&&(n=n.map(r=>r/255),n[3]=Number.isFinite(n[3])?n[3]:1,this.setState({outlineColor:n})),!t.sdf&&t.outlineWidth&&Pi.log.warn(`${this.id}: fontSettings.sdf is required to render outline`)()}draw(e){let{sdf:t,smoothing:i,outlineWidth:n}=this.props,{outlineColor:r}=this.state,s=n?Math.max(i,Nt*(1-n)):-1;if(e.uniforms={...e.uniforms,sdfBuffer:Nt,outlineBuffer:s,gamma:i,sdf:Boolean(t),outlineColor:r},super.draw(e),t&&n){let{iconManager:a}=this.state,l=a.getTexture(),c=this.state.model;l&&(c.setUniforms({outlineBuffer:Nt}),c.draw(this.context.renderPass))}}getInstanceOffset(e){return e?Array.from(e).flatMap(t=>super.getInstanceOffset(t)):vi}getInstanceColorMode(e){return 1}getInstanceIconFrame(e){return e?Array.from(e).flatMap(t=>super.getInstanceIconFrame(t)):vi}};Ne.defaultProps=Ar;Ne.layerName="MultiIconLayer";var xt=Ne;var ke=class{constructor({fontSize:e=24,buffer:t=3,radius:i=8,cutoff:n=.25,fontFamily:r="sans-serif",fontWeight:s="normal",fontStyle:a="normal"}={}){this.buffer=t,this.cutoff=n,this.radius=i;let l=this.size=e+t*4,c=this._createCanvas(l),u=this.ctx=c.getContext("2d",{willReadFrequently:!0});u.font=`${a} ${s} ${e}px ${r}`,u.textBaseline="alphabetic",u.textAlign="left",u.fillStyle="black",this.gridOuter=new Float64Array(l*l),this.gridInner=new Float64Array(l*l),this.f=new Float64Array(l),this.z=new Float64Array(l+1),this.v=new Uint16Array(l)}_createCanvas(e){let t=document.createElement("canvas");return t.width=t.height=e,t}draw(e){let{width:t,actualBoundingBoxAscent:i,actualBoundingBoxDescent:n,actualBoundingBoxLeft:r,actualBoundingBoxRight:s}=this.ctx.measureText(e),a=Math.ceil(i),l=0,c=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(s-r))),u=Math.min(this.size-this.buffer,a+Math.ceil(n)),f=c+2*this.buffer,d=u+2*this.buffer,g=Math.max(f*d,0),p=new Uint8ClampedArray(g),h={data:p,width:f,height:d,glyphWidth:c,glyphHeight:u,glyphTop:a,glyphLeft:l,glyphAdvance:t};if(c===0||u===0)return h;let{ctx:m,buffer:y,gridInner:_,gridOuter:x}=this;m.clearRect(y,y,c,u),m.fillText(e,y,y+a);let v=m.getImageData(y,y,c,u);x.fill(1e20,0,g),_.fill(0,0,g);for(let C=0;C<u;C++)for(let M=0;M<c;M++){let N=v.data[4*(C*c+M)+3]/255;if(N===0)continue;let O=(C+y)*f+M+y;if(N===1)x[O]=0,_[O]=1e20;else{let T=.5-N;x[O]=T>0?T*T:0,_[O]=T<0?T*T:0}}_i(x,0,0,f,d,f,this.f,this.v,this.z),_i(_,y,y,c,u,f,this.f,this.v,this.z);for(let C=0;C<g;C++){let M=Math.sqrt(x[C])-Math.sqrt(_[C]);p[C]=Math.round(255-255*(M/this.radius+this.cutoff))}return h}};function _i(o,e,t,i,n,r,s,a,l){for(let c=e;c<e+i;c++)Ci(o,t*r+c,r,n,s,a,l);for(let c=t;c<t+n;c++)Ci(o,c*r+e,1,i,s,a,l)}function Ci(o,e,t,i,n,r,s){r[0]=0,s[0]=-1e20,s[1]=1e20,n[0]=o[e];for(let a=1,l=0,c=0;a<i;a++){n[a]=o[e+a*t];let u=a*a;do{let f=r[l];c=(n[a]-n[f]+u-f*f)/(a-f)/2}while(c<=s[l]&&--l>-1);l++,r[l]=a,s[l]=c,s[l+1]=1e20}for(let a=0,l=0;a<i;a++){for(;s[l+1]<a;)l++;let c=r[l],u=a-c;o[e+a*t]=n[c]+u*u}}var Oi=P(L(),1);var Li=P(L(),1),br=32,zr=[];function Or(o){return Math.pow(2,Math.ceil(Math.log2(o)))}function Si({characterSet:o,getFontWidth:e,fontHeight:t,buffer:i,maxCanvasWidth:n,mapping:r={},xOffset:s=0,yOffset:a=0}){let l=0,c=s,u=t+i*2;for(let f of o)if(!r[f]){let d=e(f);c+d+i*2>n&&(c=0,l++),r[f]={x:c+i,y:a+l*u+i,width:d,height:u,layoutWidth:d,layoutHeight:t},c+=d+i*2}return{mapping:r,xOffset:c,yOffset:a+l*u,canvasHeight:Or(a+(l+1)*u)}}function wi(o,e,t,i){let n=0;for(let r=e;r<t;r++){let s=o[r];n+=i[s]?.layoutWidth||0}return n}function Mi(o,e,t,i,n,r){let s=e,a=0;for(let l=e;l<t;l++){let c=wi(o,l,l+1,n);a+c>i&&(s<l&&r.push(l),s=l,a=0),a+=c}return a}function Rr(o,e,t,i,n,r){let s=e,a=e,l=e,c=0;for(let u=e;u<t;u++)if((o[u]===" "||o[u+1]===" "||u+1===t)&&(l=u+1),l>a){let f=wi(o,a,l,n);c+f>i&&(s<a&&(r.push(a),s=a,c=0),f>i&&(f=Mi(o,a,l,i,n,r),s=r[r.length-1])),a=l,c+=f}return c}function Fr(o,e,t,i,n=0,r){r===void 0&&(r=o.length);let s=[];return e==="break-all"?Mi(o,n,r,t,i,s):Rr(o,n,r,t,i,s),s}function Dr(o,e,t,i,n,r){let s=0,a=0;for(let l=e;l<t;l++){let c=o[l],u=i[c];u?(a||(a=u.layoutHeight),n[l]=s+u.layoutWidth/2,s+=u.layoutWidth):(Li.log.warn(`Missing character: ${c} (${c.codePointAt(0)})`)(),n[l]=s,s+=br)}r[0]=s,r[1]=a}function Ti(o,e,t,i,n){let r=Array.from(o),s=r.length,a=new Array(s),l=new Array(s),c=new Array(s),u=(t==="break-word"||t==="break-all")&&isFinite(i)&&i>0,f=[0,0],d=[0,0],g=0,p=0,h=0;for(let m=0;m<=s;m++){let y=r[m];if((y===`
`||m===s)&&(h=m),h>p){let _=u?Fr(r,t,i,n,p,h):zr;for(let x=0;x<=_.length;x++){let v=x===0?p:_[x-1],C=x<_.length?_[x]:h;Dr(r,v,C,n,a,d);for(let M=v;M<C;M++){let N=r[M],O=n[N]?.layoutOffsetY||0;l[M]=g+d[1]/2+O,c[M]=d[0]}g=g+d[1]*e,f[0]=Math.max(f[0],d[0])}p=h}y===`
`&&(a[p]=0,l[p]=0,c[p]=0,p++)}return f[1]=g,{x:a,y:l,rowWidth:c,size:f}}function Ii({value:o,length:e,stride:t,offset:i,startIndices:n,characterSet:r}){let s=o.BYTES_PER_ELEMENT,a=t?t/s:1,l=i?i/s:0,c=n[e]||Math.ceil((o.length-l)/a),u=r&&new Set,f=new Array(e),d=o;if(a>1||l>0){let g=o.constructor;d=new g(c);for(let p=0;p<c;p++)d[p]=o[p*a+l]}for(let g=0;g<e;g++){let p=n[g],h=n[g+1]||c,m=d.subarray(p,h);f[g]=String.fromCodePoint.apply(null,m),u&&m.forEach(u.add,u)}if(u)for(let g of u)r.add(String.fromCodePoint(g));return{texts:f,characterCount:c}}var le=class{constructor(e=5){this._cache={},this._order=[],this.limit=e}get(e){let t=this._cache[e];return t&&(this._deleteOrder(e),this._appendOrder(e)),t}set(e,t){this._cache[e]?(this.delete(e),this._cache[e]=t,this._appendOrder(e)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[e]=t,this._appendOrder(e))}delete(e){this._cache[e]&&(delete this._cache[e],this._deleteOrder(e))}_deleteOrder(e){let t=this._order.indexOf(e);t>=0&&this._order.splice(t,1)}_appendOrder(e){this._order.push(e)}};function Nr(){let o=[];for(let e=32;e<128;e++)o.push(String.fromCharCode(e));return o}var q={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:Nr(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1},Ei=1024,Ai=.9,bi=1.2,Ri=3,yt=new le(Ri);function kr(o,e){let t;typeof e=="string"?t=new Set(Array.from(e)):t=new Set(e);let i=yt.get(o);if(!i)return t;for(let n in i.mapping)t.has(n)&&t.delete(n);return t}function Wr(o,e){for(let t=0;t<o.length;t++)e.data[4*t+3]=o[t]}function zi(o,e,t,i){o.font=`${i} ${t}px ${e}`,o.fillStyle="#000",o.textBaseline="alphabetic",o.textAlign="left"}function Fi(o){Oi.log.assert(Number.isFinite(o)&&o>=Ri,"Invalid cache limit"),yt=new le(o)}var We=class{constructor(){this.props={...q}}get atlas(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){let{fontSize:e,buffer:t}=this.props;return(e*bi+t*2)/e}setProps(e={}){Object.assign(this.props,e),this._key=this._getKey();let t=kr(this._key,this.props.characterSet),i=yt.get(this._key);if(i&&t.size===0){this._atlas!==i&&(this._atlas=i);return}let n=this._generateFontAtlas(t,i);this._atlas=n,yt.set(this._key,n)}_generateFontAtlas(e,t){let{fontFamily:i,fontWeight:n,fontSize:r,buffer:s,sdf:a,radius:l,cutoff:c}=this.props,u=t&&t.data;u||(u=document.createElement("canvas"),u.width=Ei);let f=u.getContext("2d",{willReadFrequently:!0});zi(f,i,r,n);let{mapping:d,canvasHeight:g,xOffset:p,yOffset:h}=Si({getFontWidth:m=>f.measureText(m).width,fontHeight:r*bi,buffer:s,characterSet:e,maxCanvasWidth:Ei,...t&&{mapping:t.mapping,xOffset:t.xOffset,yOffset:t.yOffset}});if(u.height!==g){let m=f.getImageData(0,0,u.width,u.height);u.height=g,f.putImageData(m,0,0)}if(zi(f,i,r,n),a){let m=new ke({fontSize:r,buffer:s,radius:l,cutoff:c,fontFamily:i,fontWeight:`${n}`});for(let y of e){let{data:_,width:x,height:v,glyphTop:C}=m.draw(y);d[y].width=x,d[y].layoutOffsetY=r*Ai-C;let M=f.createImageData(x,v);Wr(_,M),f.putImageData(M,d[y].x,d[y].y)}}else for(let m of e)f.fillText(m,d[m].x,d[m].y+s+r*Ai);return{xOffset:p,yOffset:h,mapping:d,data:u,width:u.width,height:u.height}}_getKey(){let{fontFamily:e,fontWeight:t,fontSize:i,buffer:n,sdf:r,radius:s,cutoff:a}=this.props;return r?`${e} ${t} ${i} ${n} ${s} ${a}`:`${e} ${t} ${i} ${n}`}};var H=P(L(),1),ki=P(I(),1),Wi=P(I(),1);var Di=`#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
uniform bool billboard;
uniform float opacity;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform vec4 padding;
uniform int sizeUnits;
out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = radians(angle);
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vLineWidth = instanceLineWidths;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),
sizeMinPixels, sizeMaxPixels
);
dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;
vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
pixelOffset += instancePixelOffsets;
pixelOffset.y *= -1.0;
if (billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;var Ni=`#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader
precision highp float;
uniform bool stroked;
in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec2 pixelPosition = uv * dimensions;
if (stroked) {
float distToEdge = min(
min(pixelPosition.x, dimensions.x - pixelPosition.x),
min(pixelPosition.y, dimensions.y - pixelPosition.y)
);
float isBorder = smoothedge(distToEdge, vLineWidth);
fragColor = mix(vFillColor, vLineColor, isBorder);
} else {
fragColor = vFillColor;
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Ur={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:o=>o.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}},Ue=class extends H.Layer{getShaders(){return super.getShaders({vs:Di,fs:Ni,modules:[H.project32,H.picking]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){super.updateState(e);let{changeFlags:t}=e;t.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:e}){let{billboard:t,sizeScale:i,sizeUnits:n,sizeMinPixels:r,sizeMaxPixels:s,getLineWidth:a}=this.props,{padding:l}=this.props;l.length<4&&(l=[l[0],l[1],l[0],l[1]]);let c=this.state.model;c.setUniforms(e),c.setUniforms({billboard:t,stroked:Boolean(a),padding:l,sizeUnits:H.UNIT[n],sizeScale:i,sizeMinPixels:r,sizeMaxPixels:s}),c.draw(this.context.renderPass)}_getModel(){let e=[0,0,1,0,1,1,0,1];return new Wi.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new ki.Geometry({topology:"triangle-fan-webgl",vertexCount:4,attributes:{positions:{size:2,value:new Float32Array(e)}}}),isInstanced:!0})}};Ue.defaultProps=Ur;Ue.layerName="TextBackgroundLayer";var vt=Ue;var Ui={start:1,middle:0,end:-1},Gi={top:1,center:0,bottom:-1},kt=[0,0,0,255],Gr=1,Br={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:kt},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:q.characterSet},fontFamily:q.fontFamily,fontWeight:q.fontWeight,lineHeight:Gr,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:kt},fontSettings:{type:"object",value:{},compare:1},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:o=>o.text},getPosition:{type:"accessor",value:o=>o.position},getColor:{type:"accessor",value:kt},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}},Ge=class extends ce.CompositeLayer{constructor(){super(...arguments),this.getBoundingRect=(e,t)=>{let{size:[i,n]}=this.transformParagraph(e,t),{fontSize:r}=this.state.fontAtlasManager.props;i/=r,n/=r;let{getTextAnchor:s,getAlignmentBaseline:a}=this.props,l=Ui[typeof s=="function"?s(e,t):s],c=Gi[typeof a=="function"?a(e,t):a];return[(l-1)*i/2,(c-1)*n/2,i,n]},this.getIconOffsets=(e,t)=>{let{getTextAnchor:i,getAlignmentBaseline:n}=this.props,{x:r,y:s,rowWidth:a,size:[l,c]}=this.transformParagraph(e,t),u=Ui[typeof i=="function"?i(e,t):i],f=Gi[typeof n=="function"?n(e,t):n],d=r.length,g=new Array(d*2),p=0;for(let h=0;h<d;h++){let m=(1-u)*(l-a[h])/2;g[p++]=(u-1)*l/2+m+r[h],g[p++]=(f-1)*c/2+s[h]}return g}}initializeState(){this.state={styleVersion:0,fontAtlasManager:new We},this.props.maxWidth>0&&ce.log.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()}updateState(e){let{props:t,oldProps:i,changeFlags:n}=e;(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getText))&&this._updateText(),(this._updateFontAtlas()||t.lineHeight!==i.lineHeight||t.wordBreak!==i.wordBreak||t.maxWidth!==i.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:e}){return e.object=e.index>=0?this.props.data[e.index]:null,e}_updateFontAtlas(){let{fontSettings:e,fontFamily:t,fontWeight:i}=this.props,{fontAtlasManager:n,characterSet:r}=this.state,s={...e,characterSet:r,fontFamily:t,fontWeight:i};if(!n.mapping)return n.setProps(s),!0;for(let a in s)if(s[a]!==n.props[a])return n.setProps(s),!0;return!1}_updateText(){let{data:e,characterSet:t}=this.props,i=e.attributes?.getText,{getText:n}=this.props,r=e.startIndices,s,a=t==="auto"&&new Set;if(i&&r){let{texts:l,characterCount:c}=Ii({...ArrayBuffer.isView(i)?{value:i}:i,length:e.length,startIndices:r,characterSet:a});s=c,n=(u,{index:f})=>l[f]}else{let{iterable:l,objectInfo:c}=(0,ce.createIterable)(e);r=[0],s=0;for(let u of l){c.index++;let f=Array.from(n(u,c)||"");a&&f.forEach(a.add,a),s+=f.length,r.push(s)}}this.setState({getText:n,startIndices:r,numInstances:s,characterSet:a||t})}transformParagraph(e,t){let{fontAtlasManager:i}=this.state,n=i.mapping,r=this.state.getText,{wordBreak:s,lineHeight:a,maxWidth:l}=this.props,c=r(e,t)||"";return Ti(c,a,s,l*i.props.fontSize,n)}renderLayers(){let{startIndices:e,numInstances:t,getText:i,fontAtlasManager:{scale:n,atlas:r,mapping:s},styleVersion:a}=this.state,{data:l,_dataDiff:c,getPosition:u,getColor:f,getSize:d,getAngle:g,getPixelOffset:p,getBackgroundColor:h,getBorderColor:m,getBorderWidth:y,backgroundPadding:_,background:x,billboard:v,fontSettings:C,outlineWidth:M,outlineColor:N,sizeScale:O,sizeUnits:T,sizeMinPixels:He,sizeMaxPixels:Q,transitions:E,updateTriggers:w}=this.props,St=this.getSubLayerClass("characters",xt),Ke=this.getSubLayerClass("background",vt);return[x&&new Ke({getFillColor:h,getLineColor:m,getLineWidth:y,padding:_,getPosition:u,getSize:d,getAngle:g,getPixelOffset:p,billboard:v,sizeScale:O,sizeUnits:T,sizeMinPixels:He,sizeMaxPixels:Q,transitions:E&&{getPosition:E.getPosition,getAngle:E.getAngle,getSize:E.getSize,getFillColor:E.getBackgroundColor,getLineColor:E.getBorderColor,getLineWidth:E.getBorderWidth,getPixelOffset:E.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:w.getPosition,getAngle:w.getAngle,getSize:w.getSize,getFillColor:w.getBackgroundColor,getLineColor:w.getBorderColor,getLineWidth:w.getBorderWidth,getPixelOffset:w.getPixelOffset,getBoundingRect:{getText:w.getText,getTextAnchor:w.getTextAnchor,getAlignmentBaseline:w.getAlignmentBaseline,styleVersion:a}}}),{data:l.attributes&&l.attributes.background?{length:l.length,attributes:l.attributes.background}:l,_dataDiff:c,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new St({sdf:C.sdf,smoothing:Number.isFinite(C.smoothing)?C.smoothing:q.smoothing,outlineWidth:M/(C.radius||q.radius),outlineColor:N,iconAtlas:r,iconMapping:s,getPosition:u,getColor:f,getSize:d,getAngle:g,getPixelOffset:p,billboard:v,sizeScale:O*n,sizeUnits:T,sizeMinPixels:He*n,sizeMaxPixels:Q*n,transitions:E&&{getPosition:E.getPosition,getAngle:E.getAngle,getColor:E.getColor,getSize:E.getSize,getPixelOffset:E.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{all:w.getText,getPosition:w.getPosition,getAngle:w.getAngle,getColor:w.getColor,getSize:w.getSize,getPixelOffset:w.getPixelOffset,getIconOffsets:{getTextAnchor:w.getTextAnchor,getAlignmentBaseline:w.getAlignmentBaseline,styleVersion:a}}}),{data:l,_dataDiff:c,startIndices:e,numInstances:t,getIconOffsets:this.getIconOffsets,getIcon:i})]}static set fontAtlasCacheLimit(e){Fi(e)}};Ge.defaultProps=Br;Ge.layerName="TextLayer";var Pt=Ge;var Be={circle:{type:tt,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",pointAntialiasing:"antialiasing",pointBillboard:"billboard",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:te,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",iconAlphaCutoff:"alphaCutoff",iconBillboard:"billboard",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:Pt,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",textBillboard:"billboard",textFontSettings:"fontSettings",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},je={type:ie,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",lineBillboard:"billboard",getLineColor:"getColor",getLineWidth:"getWidth"}},_t={type:se,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",_full3d:"_full3d",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function ue({type:o,props:e}){let t={};for(let i in e)t[i]=o.defaultProps[e[i]];return t}function Ct(o,e){let{transitions:t,updateTriggers:i}=o.props,n={updateTriggers:{},transitions:t&&{getPosition:t.geometry}};for(let r in e){let s=e[r],a=o.props[r];r.startsWith("get")&&(a=o.getSubLayerAccessor(a),n.updateTriggers[s]=i[r],t&&(n.transitions[s]=t[r])),n[s]=a}return n}var fe=P(L(),1);function ji(o){if(Array.isArray(o))return o;switch(fe.log.assert(o.type,"GeoJSON does not have type"),o.type){case"Feature":return[o];case"FeatureCollection":return fe.log.assert(Array.isArray(o.features),"GeoJSON does not have features array"),o.features;default:return[{geometry:o}]}}function Wt(o,e,t={}){let i={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:n=0,endRow:r=o.length}=t;for(let s=n;s<r;s++){let a=o[s],{geometry:l}=a;if(l)if(l.type==="GeometryCollection"){fe.log.assert(Array.isArray(l.geometries),"GeoJSON does not have geometries array");let{geometries:c}=l;for(let u=0;u<c.length;u++){let f=c[u];Bi(f,i,e,a,s)}}else Bi(l,i,e,a,s)}return i}function Bi(o,e,t,i,n){let{type:r,coordinates:s}=o,{pointFeatures:a,lineFeatures:l,polygonFeatures:c,polygonOutlineFeatures:u}=e;if(!Vr(r,s)){fe.log.warn(`${r} coordinates are malformed`)();return}switch(r){case"Point":a.push(t({geometry:o},i,n));break;case"MultiPoint":s.forEach(f=>{a.push(t({geometry:{type:"Point",coordinates:f}},i,n))});break;case"LineString":l.push(t({geometry:o},i,n));break;case"MultiLineString":s.forEach(f=>{l.push(t({geometry:{type:"LineString",coordinates:f}},i,n))});break;case"Polygon":c.push(t({geometry:o},i,n)),s.forEach(f=>{u.push(t({geometry:{type:"LineString",coordinates:f}},i,n))});break;case"MultiPolygon":s.forEach(f=>{c.push(t({geometry:{type:"Polygon",coordinates:f}},i,n)),f.forEach(d=>{u.push(t({geometry:{type:"LineString",coordinates:d}},i,n))})});break;default:}}var jr={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function Vr(o,e){let t=jr[o];for(fe.log.assert(t,`Unknown GeoJSON type ${o}`);e&&--t>0;)e=e[0];return e&&Number.isFinite(e[0])}function Vi(){return{points:{},lines:{},polygons:{},polygonsOutline:{}}}function Lt(o){return o.geometry.coordinates}function Zi(o,e){let t=Vi(),{pointFeatures:i,lineFeatures:n,polygonFeatures:r,polygonOutlineFeatures:s}=o;return t.points.data=i,t.points._dataDiff=e.pointFeatures&&(()=>e.pointFeatures),t.points.getPosition=Lt,t.lines.data=n,t.lines._dataDiff=e.lineFeatures&&(()=>e.lineFeatures),t.lines.getPath=Lt,t.polygons.data=r,t.polygons._dataDiff=e.polygonFeatures&&(()=>e.polygonFeatures),t.polygons.getPolygon=Lt,t.polygonsOutline.data=s,t.polygonsOutline._dataDiff=e.polygonOutlineFeatures&&(()=>e.polygonOutlineFeatures),t.polygonsOutline.getPath=Lt,t}function Hi(o,e){let t=Vi(),{points:i,lines:n,polygons:r}=o,s=xi(o,e);return t.points.data={length:i.positions.value.length/i.positions.size,attributes:{...i.attributes,getPosition:i.positions,instancePickingColors:{size:4,value:s.points}},properties:i.properties,numericProps:i.numericProps,featureIds:i.featureIds},t.lines.data={length:n.pathIndices.value.length-1,startIndices:n.pathIndices.value,attributes:{...n.attributes,getPath:n.positions,instancePickingColors:{size:4,value:s.lines}},properties:n.properties,numericProps:n.numericProps,featureIds:n.featureIds},t.lines._pathType="open",t.polygons.data={length:r.polygonIndices.value.length-1,startIndices:r.polygonIndices.value,attributes:{...r.attributes,getPolygon:r.positions,pickingColors:{size:4,value:s.polygons}},properties:r.properties,numericProps:r.numericProps,featureIds:r.featureIds},t.polygons._normalize=!1,r.triangles&&(t.polygons.data.attributes.indices=r.triangles.value),t.polygonsOutline.data={length:r.primitivePolygonIndices.value.length-1,startIndices:r.primitivePolygonIndices.value,attributes:{...r.attributes,getPath:r.positions,instancePickingColors:{size:4,value:s.polygons}},properties:r.properties,numericProps:r.numericProps,featureIds:r.featureIds},t.polygonsOutline._pathType="open",t}var Zr=["points","linestrings","polygons"],Hr={...ue(Be.circle),...ue(Be.icon),...ue(Be.text),...ue(je),...ue(_t),stroked:!0,filled:!0,extruded:!1,wireframe:!1,_full3d:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:o=>o.properties.icon},getText:{type:"accessor",value:o=>o.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}},Ve=class extends Ki.CompositeLayer{initializeState(){this.state={layerProps:{},features:{},featuresDiff:{}}}updateState({props:e,changeFlags:t}){if(!t.dataChanged)return;let{data:i}=this.props,n=i&&"points"in i&&"polygons"in i&&"lines"in i;this.setState({binary:n}),n?this._updateStateBinary({props:e,changeFlags:t}):this._updateStateJSON({props:e,changeFlags:t})}_updateStateBinary({props:e,changeFlags:t}){let i=Hi(e.data,this.encodePickingColor);this.setState({layerProps:i})}_updateStateJSON({props:e,changeFlags:t}){let i=ji(e.data),n=this.getSubLayerRow.bind(this),r={},s={};if(Array.isArray(t.dataChanged)){let l=this.state.features;for(let c in l)r[c]=l[c].slice(),s[c]=[];for(let c of t.dataChanged){let u=Wt(i,n,c);for(let f in l)s[f].push(mt({data:r[f],getIndex:d=>d.__source.index,dataRange:c,replace:u[f]}))}}else r=Wt(i,n);let a=Zi(r,s);this.setState({features:r,featuresDiff:s,layerProps:a})}getPickingInfo(e){let t=super.getPickingInfo(e),{index:i,sourceLayer:n}=t;return t.featureType=Zr.find(r=>n.id.startsWith(`${this.id}-${r}-`)),i>=0&&n.id.startsWith(`${this.id}-points-text`)&&this.state.binary&&(t.index=this.props.data.points.globalFeatureIds.value[i]),t}_updateAutoHighlight(e){let t=`${this.id}-points-`,i=e.featureType==="points";for(let n of this.getSubLayers())n.id.startsWith(t)===i&&n.updateAutoHighlight(e)}_renderPolygonLayer(){let{extruded:e,wireframe:t}=this.props,{layerProps:i}=this.state,n="polygons-fill",r=this.shouldRenderSubLayer(n,i.polygons?.data)&&this.getSubLayerClass(n,_t.type);if(r){let s=Ct(this,_t.props),a=e&&t;return a||delete s.getLineColor,s.updateTriggers.lineColors=a,new r(s,this.getSubLayerProps({id:n,updateTriggers:s.updateTriggers}),i.polygons)}return null}_renderLineLayers(){let{extruded:e,stroked:t}=this.props,{layerProps:i}=this.state,n="polygons-stroke",r="linestrings",s=!e&&t&&this.shouldRenderSubLayer(n,i.polygonsOutline?.data)&&this.getSubLayerClass(n,je.type),a=this.shouldRenderSubLayer(r,i.lines?.data)&&this.getSubLayerClass(r,je.type);if(s||a){let l=Ct(this,je.props);return[s&&new s(l,this.getSubLayerProps({id:n,updateTriggers:l.updateTriggers}),i.polygonsOutline),a&&new a(l,this.getSubLayerProps({id:r,updateTriggers:l.updateTriggers}),i.lines)]}return null}_renderPointLayers(){let{pointType:e}=this.props,{layerProps:t,binary:i}=this.state,{highlightedObjectIndex:n}=this.props;!i&&Number.isFinite(n)&&(n=t.points.data.findIndex(a=>a.__source.index===n));let r=new Set(e.split("+")),s=[];for(let a of r){let l=`points-${a}`,c=Be[a],u=c&&this.shouldRenderSubLayer(l,t.points?.data)&&this.getSubLayerClass(l,c.type);if(u){let f=Ct(this,c.props),d=t.points;if(a==="text"&&i){let{instancePickingColors:g,...p}=d.data.attributes;d={...d,data:{...d.data,attributes:p}}}s.push(new u(f,this.getSubLayerProps({id:l,updateTriggers:f.updateTriggers,highlightedObjectIndex:n}),d))}}return s}renderLayers(){let{extruded:e}=this.props,t=this._renderPolygonLayer(),i=this._renderLineLayers(),n=this._renderPointLayers();return[!e&&t,i,n,e&&t]}getSubLayerAccessor(e){let{binary:t}=this.state;return!t||typeof e!="function"?super.getSubLayerAccessor(e):(i,n)=>{let{data:r,index:s}=n,a=mi(r,s);return e(a,n)}}};Ve.layerName="GeoJsonLayer";Ve.defaultProps=Hr;var $i=Ve;return nn(Ze);})();
      return __exports__;
      });
